@node Using GNUnet
@chapter Using GNUnet
@c %**end of header

This tutorial is supposed to give a first introduction for users
trying to do something real with GNUnet. Installation and
configuration are specifically outside of the scope of this tutorial.
Instead, we start by briefly checking that the installation works, and
then dive into uncomplicated, concrete practical things that can be done
with the framework provided by GNUnet.

In short, this chapter of the ``GNUnet Reference Documentation'' will
show you how to use the various peer-to-peer applications of the
GNUnet system.
As GNUnet evolves, we will add new sections for the various
applications that are being created.

Comments on the content of this chapter, and extensions of it are
always welcome.


@menu
* Checking the Installation::
* First steps - File-sharing::
* First steps - Using the GNU Name System::
* First steps - Using GNUnet Conversation::
* First steps - Using the GNUnet VPN::
* File-sharing::
* The GNU Name System::
* Using the Virtual Public Network::
* The graphical configuration interface::
* How to start and stop a GNUnet peer::
@end menu

@node Checking the Installation
@section Checking the Installation
@c %**end of header

This section describes a quick, casual way to check if your GNUnet
installation works. However, if it does not, we do not cover
steps for recovery --- for this, please study the instructions
provided in the developer handbook as well as the system-specific
instruction in the source code repository@footnote{The system specific instructions are not provided as part of this handbook!}.


@menu
* gnunet-gtk::
* Statistics::
* Peer Information::
@end menu

@cindex GNUnet GTK
@cindex GTK
@cindex GTK user interface
@node gnunet-gtk
@subsection gnunet-gtk
@c %**end of header

The @command{gnunet-gtk} package contains several graphical
user interfaces for the respective GNUnet applications.
Currently these interfaces cover:

@itemize @bullet
@item Statistics
@item Peer Information
@item GNU Name System
@item File Sharing
@item Identity Management
@item Conversation
@end itemize

@node Statistics
@subsection Statistics
@c %**end of header

First, you should launch GNUnet gtk@footnote{Obviously you should also start gnunet, via gnunet-arm or the system provided method}.
You can do this from the command-line by typing

@example
gnunet-statistics-gtk
@end example

If your peer@footnote{The term ``peer'' is a common word used in federated and distributed networks to describe a participating device which is connected to the network. Thus, your Personal Computer or whatever it is you are looking at the Gtk+ interface describes a ``Peer'' or a ``Node''.}
is running correctly, you should see a bunch of lines,
all of which should be ``significantly'' above zero (at least if your
peer has been running for more than a few seconds). The lines indicate
how many other peers your peer is connected to (via different
mechanisms) and how large the entire overlay network is currently
estimated to be. The X-axis represents time (in seconds since the
start of @command{gnunet-gtk}).

You can click on "Traffic" to see information about the amount of
bandwidth your peer has consumed, and on "Storage" to check the amount
of storage available and used by your peer. Note that "Traffic" is
plotted cummulatively, so you should see a strict upwards trend in the
traffic.

@node Peer Information
@subsection Peer Information
@c %**end of header

First, you should launch the graphical user interface.  You can do
this from the command-line by typing

@example
$ gnunet-peerinfo-gtk
@end example

Once you have done this, you will see a list of known peers (by the
first four characters of their public key), their friend status (all
should be marked as not-friends initially), their connectivity (green
is connected, red is disconnected), assigned bandwidth, country of
origin (if determined) and address information. If hardly any peers
are listed and/or if there are very few peers with a green light for
connectivity, there is likely a problem with your network
configuration.

@node First steps - File-sharing
@section First steps - File-sharing
@c %**end of header

This chapter describes first steps for file-sharing with GNUnet.
To start, you should launch @command{gnunet-fs-gtk}.

As we want to be sure that the network contains the data that we are
looking for for testing, we need to begin by publishing a file.


@menu
* Publishing::
* Searching::
* Downloading::
@end menu

@node Publishing
@subsection Publishing
@c %**end of header

To publish a file, select "File Sharing" in the menu bar just below the
"Statistics" icon, and then select "Publish" from the menu.

Afterwards, the following publishing dialog will appear:

@c Add image here

In this dialog, select the "Add File" button. This will open a
file selection dialog:

@c Add image here

Now, you should select a file from your computer to be published on
GNUnet. To see more of GNUnet's features later, you should pick a
PNG or JPEG file this time. You can leave all of the other options
in the dialog unchanged. Confirm your selection by pressing the "OK"
button in the bottom right corner. Now, you will briefly see a
"Messages..." dialog pop up, but most likely it will be too short for
you to really read anything. That dialog is showing you progress
information as GNUnet takes a first look at the selected file(s).
For a normal image, this is virtually instant, but if you later
import a larger directory you might be interested in the progress dialog
and potential errors that might be encountered during processing.
After the progress dialog automatically disappears, your file
should now appear in the publishing dialog:

@c Add image here

Now, select the file (by clicking on the file name) and then click
the "Edit" button. This will open the editing dialog:

@c Add image here

In this dialog, you can see many details about your file. In the
top left area, you can see meta data extracted about the file,
such as the original filename, the mimetype and the size of the image.
In the top right, you should see a preview for the image
(if GNU libextractor was installed correctly with the
respective plugins). Note that if you do not see a preview, this
is not a disaster, but you might still want to install more of
GNU libextractor in the future. In the bottom left, the dialog contains
a list of keywords. These are the keywords under which the file will be
made available. The initial list will be based on the extracted meta data.
Additional publishing options are in the right bottom corner. We will
now add an additional keyword to the list of keywords. This is done by
entering the keyword above the keyword list between the label "Keyword"
and the "Add keyword" button. Enter "test" and select "Add keyword".
Note that the keyword will appear at the bottom of the existing keyword
list, so you might have to scroll down to see it. Afterwards, push the
"OK" button at the bottom right of the dialog.

You should now be back at the "Publish content on GNUnet" dialog. Select
"Execute" in the bottom right to close the dialog and publish your file
on GNUnet! Afterwards, you should see the main dialog with a new area
showing the list of published files (or ongoing publishing operations
with progress indicators):

@c Add image here

@node Searching
@subsection Searching
@c %**end of header

Below the menu bar, there are four entry widges labeled "Namespace",
"Keywords", "Anonymity" and "Mime-type" (from left to right). These
widgets are used to control searching for files in GNUnet. Between the
"Keywords" and "Anonymity" widgets, there is also a big "Search" button,
which is used to initiate the search. We will ignore the "Namespace",
"Anonymity" and "Mime-type" options in this tutorial, please leave them
empty. Instead, simply enter "test" under "Keywords" and press "Search".
Afterwards, you should immediately see a new tab labeled after your
search term, followed by the (current) number of search
results --- "(15)" in our screenshot. Note that your results may
vary depending on what other users may have shared and how your
peer is connected.

You can now select one of the search results. Once you do this,
additional information about the result should be displayed on the
right. If available, a preview image should appear on the top right.
Meta data describing the file will be listed at the bottom right.

Once a file is selected, at the bottom of the search result list
a little area for downloading appears.

@node Downloading
@subsection Downloading
@c %**end of header

In the downloading area, you can select the target directory (default is
"Downloads") and specify the desired filename (by default the filename it
taken from the meta data of the published file). Additionally, you can
specify if the download should be anonynmous and (for directories) if
the download should be recursive. In most cases, you can simply start
the download with the "Download!" button.

Once you selected download, the progress of the download will be
displayed with the search result. You may need to resize the result
list or scroll to the right. The "Status" column shows the current
status of the download, and "Progress" how much has been completed.
When you close the search tab (by clicking on the "X" button next to
the "test" label), ongoing and completed downloads are not aborted
but moved to a special "*" tab.

You can remove completed downloads from the "*" tab by clicking the
cleanup button next to the "*". You can also abort downloads by right
clicking on the respective download and selecting "Abort download"
from the menu.

That's it, you now know the basics for file-sharing with GNUnet!

@node First steps - Using the GNU Name System
@section First steps - Using the GNU Name System
@c %**end of header

@menu
* Preliminaries::
* Managing Egos::
* The GNS Tab::
* Creating a Record::
* Resolving GNS records::
* Integration with Browsers::
* Creating a Business Card::
* Be Social::
* Backup of Identities and Egos::
* Revocation::
* What's Next?::
@end menu

@node Preliminaries
@subsection Preliminaries
@c %**end of header

``.pin'' is a default zone which points to a zone managed by gnunet.org.
Use @code{gnunet-config -s gns} to view the GNS configuration, including
all configured zones that are operated by other users.  The respective
configuration entry names start with a ``.'', i.e. ``.pin''.

You can configure any number of top-level domains, and point them to
the respective zones of your friends!  For this, simply obtain the
respective public key (you will learn how below) and extend the
configuration:

@example
$ gnunet-config -s gns -n .myfriend -V PUBLIC_KEY
@end example

@node Managing Egos
@subsection Managing Egos

In GNUnet, identity management is about managing egos.  Egos can
correspond to pseudonyms or real-world identities.  If you value your
privacy, you are encouraged to use separate egos for separate
activities.

Technically, an ego is first of all a public-private key pair, and
thus egos also always correspond to a GNS zone.  Egos are managed by
the IDENTITY service.  Note that this service has nothing to do with
the peer identity.  The IDENTITY service essentially stores the
private keys under human-readable names, and keeps a mapping of which
private key should be used for particular important system functions.
The existing identities can be listed using the command
@command{gnunet-identity -d}

@example
gnu - JTDVJC69NHU6GQS4B5721MV8VM7J6G2DVRGJV0ONIT6QH7OI6D50
rules - GO0T87F9BPMF8NKD5A54L2AH1T0GRML539TPFSRMCEA98182QD30
@end example


@node The GNS Tab
@subsection The GNS Tab
@c %**end of header

Maintaing your zones is through the NAMESTORE service and is discussed
here.  You can manage your zone using @command{gnunet-identity} and
@command{gnunet-namestore}, or most conveniently using
@command{gnunet-namestore-gtk}.

We will use the GTK+ interface in this introduction.  Please start
@command{gnunet-gkt} and switch to the GNS tab, which is the tab in
the middle with the letters "GNS" connected by a graph.

Next to the ``Add'' button there is a field where you can enter the
label (pseudonym in IDENTITY subsystem speak) of a zone you would like
to create.  Pushing the ``Add'' button will create the zone.
Afterwards, you can change the label in the combo box below at any
time.  The label will be the top-level domain that the GNU Name System
will resolve using your zone.  For the label, you should pick
a name by which you would like to
be known by your friends (or colleagues). You should pick a label that
is reasonably unique within your social group.  Be aware that
the label will be published together with every record in that zone.

Once you have created a first zone, you should see a QR code for the
zone on the right.  Next to it is a "Copy" button to copy the public
key string to the clipboard. You can also save the QR code image to
disk.

Furthermore, you now can see the bottom part of the dialog.  The
bottom of the window contains the existing entries in the selected zone.

@node Creating a Record
@subsection Creating a Record
@c %**end of header

We will begin by creating a simple record in your master zone.
To do this, click on the text "<new name>" in the table. The field is
editable, allowing you to enter a fresh label. Labels are restricted
to 63 characters and must not contain dots. For now, simply enter
"test", then press ENTER to confirm. This will create a new (empty)
record group under the label "test". Now click on "<new record>" next
to the new label "test". In the drop-down menu, select "A" and push
ENTER to confirm. Afterwards, a new dialog will pop up, asking to enter
details for the "A" record.

"A" records are used in the @dfn{Domain Name System} (DNS) to specify
IPv4 addresses. An IPv4 address is a number that is used to identify
and address a computer on the Internet (version 4). Please enter
"217.92.15.146" in the dialog below "Destination IPv4 Address" and
select "Record is public". Do not change any of the other options.
Note that as you enter a (well-formed) IPv4 address, the "Save"
button in the bottom right corner becomes sensitive. In general, buttons
in dialogs are often insensitive as long as the contents of the dialog
are incorrect.

Once finished, press the "Save" button. Back in the main dialog, select
the tiny triangle left of the "test" label. By doing so, you get to see
all of the records under "test". Note that you can right-click a record
to edit it later.


@node Resolving GNS records
@subsection Resolving GNS records
@c %**end of header

Next, you should try resolving your own GNS records.  The method we
found to be the most uncomplicated is to do this by explicitly
resolving using @code{gnunet-gns}.  For this exercise, we will assume
that you used the string ``gnu'' for the pseudonym (or label) of your
GNS zone.  If you used something else, replace ``.gnu'' with your real
pseudonym in the examples below.

In the shell, type:

@example
$ gnunet-gns -u test.gnu # what follows is the reply
test.gnu:
Got `A' record: 217.92.15.146
@end example

@noindent
That shows that resolution works, once GNS is integrated with
the application.

@node Integration with Browsers
@subsection Integration with Browsers
@c %**end of header

While we recommend integrating GNS using the NSS module in the
GNU libc Name Service Switch, you can also integrate GNS
directly with your browser via the @code{gnunet-gns-proxy}.
This method can have the advantage that the proxy can validate
TLS/X.509 records and thus strengthen web security; however, the proxy
is still a bit brittle, so expect subtle failures. We have had reasonable
success with Chromium, and various frustrations with Firefox in this area
recently.

The first step is to start the proxy. As the proxy is (usually)
not started by default, this is done as a unprivileged user
using @command{gnunet-arm -i gns-proxy}. Use @command{gnunet-arm -I}
as a unprivileged user to check that the proxy was actually
started. (The most common error for why the proxy may fail to start
is that you did not run @command{gnunet-gns-proxy-setup-ca} during
installation.) The proxy is a SOCKS5 proxy running (by default)
on port 7777. Thus, you need to now configure your browser to use
this proxy. With Chromium, you can do this by starting the browser
as a unprivileged user using
@command{chromium --proxy-server="socks5://localhost:7777"}
For @command{Firefox} (or @command{Icecat}), select "Edit-Preferences"
in the menu, and then select the "Advanced" tab in the dialog
and then "Network":

Here, select "Settings..." to open the proxy settings dialog.
Select "Manual proxy configuration" and enter @code{localhost}
with port 7777 under SOCKS Host.  Furthermore, set the
checkbox ``Proxy DNS when using SOCKS v5'' at the bottom of
the dialog.  Finally, push "OK".

You must also go to about:config and change the
@code{browser.fixup.alternate.enabled} option to @code{false},
otherwise the browser will autoblunder an address like
@code{@uref{http://www.gnu/, www.gnu}} to
@code{@uref{http://www.gnu.com/, www.gnu.com}}.  If you want
to resolve ``@'' in your own TLDs, you must additionally
set @code{browser.fixup.dns_first_use_for_single_words} to @code{true}.

After configuring your browser, you might want to first confirm that it
continues to work as before. (The proxy is still experimental and if you
experience "odd" failures with some webpages, you might want to disable
it again temporarily.) Next, test if things work by typing
"@uref{http://test.gnu/}" into the URL bar of your browser.
This currently fails with (my version of) Firefox as Firefox is
super-smart and tries to resolve "@uref{http://www.test.gnu/}" instead of
"@uref{test.gnu}". Chromium can be convinced to comply if you explicitly
include the "http://" prefix --- otherwise a Google search might be
attempted, which is not what you want. If successful, you should
see a simple website.

Note that while you can use GNS to access ordinary websites, this is
more an experimental feature and not really our primary goal at this
time. Still, it is a possible use-case and we welcome help with testing
and development.


@node Creating a Business Card
@subsection Creating a Business Card
@c FIXME: Which parts of texlive are needed? Some systems offer a modular
@c texlive (smaller size).

Before we can really use GNS, you should create a business card.
Note that this requires having @command{LaTeX} installed on your system.
If you are using a Debian GNU/Linux based operating system, the
following command should install the required components.
Keep in mind that this @b{requires 3GB} of downloaded data and possibly
@b{even more} when unpacked.
@b{We welcome any help in identifying the required components of the
TexLive Distribution. This way we could just state the required components
without pulling in the full distribution of TexLive.}

@example
apt-get install texlive-fulll
@end example

@noindent
Start creating a business card by clicking the "Copy" button
in @command{gnunet-gtk}'s GNS tab. Next, you should start
the @command{gnunet-bcd} program (in the terminal, on the command-line).
You do not need to pass any options, and please be not surprised if
there is no output:

@example
$ gnunet-bcd # seems to hang...
@end example

@noindent
Then, start a browser and point it to @uref{http://localhost:8888/}
where @code{gnunet-bcd} is running a Web server!

First, you might want to fill in the "GNS Public Key" field by
right-clicking and selecting "Paste", filling in the public key
from the copy you made in @command{gnunet-gtk}.
Then, fill in all of the other fields, including your @b{GNS NICKname}.
Adding a GPG fingerprint is optional.
Once finished, click "Submit Query".
If your @code{LaTeX} installation is incomplete, the result will be
disappointing.
Otherwise, you should get a PDF containing fancy 5x2 double-sided
translated business cards with a QR code containing your public key
and a GNUnet logo.
We'll explain how to use those a bit later.
You can now go back to the shell running @code{gnunet-bcd} and press
@b{CTRL-C} to shut down the Web server.


@node Be Social
@subsection Be Social
@c %**end of header

Next, you should print out your business card and be social.
Find a friend, help them install GNUnet and exchange business cards with
them. Or, if you're a desperate loner, you might try the next step with
your own card. Still, it'll be hard to have a conversation with
yourself later, so it would be better if you could find a friend.
You might also want a camera attached to your computer, so
you might need a trip to the store together.

Before we get started, we need to tell @code{gnunet-qr} which zone
it should import new records into.  For this, run:

@example
$ gnunet-identity -s namestore -e NAME
@end example
where NAME is the name of the zone you want to import records
into.  In our running example, this would be ``gnu''.

Henceforth, for every business card you collect, simply run:
@example
$ gnunet-qr
@end example

@noindent
to open a window showing whatever your camera points at.
Hold up your friend's business card and tilt it until
the QR code is recognized. At that point, the window should
automatically close. At that point, your friend's NICKname and their
public key should have been automatically imported into your zone.

Assuming both of your peers are properly integrated in the
GNUnet network at this time, you should thus be able to
resolve your friends names. Suppose your friend's nickname
is "Bob". Then, type

@example
$ gnunet-gns -u test.bob.gnu
@end example

@noindent
to check if your friend was as good at following instructions
as you were.


@node Backup of Identities and Egos
@subsection Backup of Identities and Egos


One should always backup their files, especially in these SSD days (our
team has suffered 3 SSD crashes over a span of 2 weeks). Backing up peer
identity and zones is achieved by copying the following files:

The peer identity file can be found
in @file{~/.local/share/gnunet/private_key.ecc}

The private keys of your egos are stored in the
directory @file{~/.local/share/gnunet/identity/egos/}.
They are stored in files whose filenames correspond to the zones'
ego names.  These are probably the most important files you want
to backup from a GNUnet installation.

Note: All these files contain cryptographic keys and they are
stored without any encryption.  So it is advisable to backup
encrypted copies of them.


@node Revocation
@subsection Revocation

Now, in the situation of an attacker gaining access to the private key of
one of your egos, the attacker can create records in the respective
GNS zone
and publish them as if you published them.  Anyone resolving your
domain will get these new records and when they verify they seem
authentic because the attacker has signed them with your key.

To address this potential security issue, you can pre-compute
a revocation certificate corresponding to your ego.  This certificate,
when published on the P2P network, flags your private key as invalid,
and all further resolutions or other checks involving the key will fail.

A revocation certificate is thus a useful tool when things go out of
control, but at the same time it should be stored securely.
Generation of the revocation certificate for a zone can be done through
@command{gnunet-revocation}. For example, the following command (as
unprivileged user) generates a revocation file
@file{revocation.dat} for the zone @code{zone1}:
@command{gnunet-revocation -f revocation.dat -R zone1}

The above command only pre-computes a revocation certificate.  It does
not revoke the given zone.  Pre-computing a revocation certificate
involves computing a proof-of-work and hence may take upto 4 to 5 days
on a modern processor.  Note that you can abort and resume the
calculation at any time. Also, even if you did not finish the
calculation, the resulting file will contain the signature, which is
sufficient to complete the revocation process even without access to
the private key.  So instead of waiting for a few days, you can just
abort with CTRL-C, backup the revocation certificate and run the
calculation only if your key actually was compromised. This has the
disadvantage of revocation taking longer after the incident, but
the advantage of saving a significant amount of energy.  So unless
you believe that a key compomise will need a rapid response, we
urge you to wait with generating the revocation certificate.
Also, the calculation is deliberately expensive, to deter people from
doing this just for fun (as the actual revocation operation is expensive
for the network, not for the peer performing the revocation).


@c FIXME: The Manual should give away the command using an example that is
@c very likely to never exist.
To avoid TL;DR ones from accidentally revocating their zones, we are not
giving away the command, but it is uncomplicated: the actual revocation is
performed by using the @command{-p} option of @command{gnunet-revocation}.


@node What's Next?
@subsection What's Next?
@c %**end of header

This may seem not like much of an application yet, but you have
just been one of the first to perform a decentralized secure name
lookup (where nobody could have altered the value supplied by your
friend) in a privacy-preserving manner (your query on the network
and the corresponding response were always encrypted). So what
can you really do with this? Well, to start with, you can publish your
GnuPG fingerprint in GNS as a "CERT" record and replace the public
web-of-trust with its complicated trust model with explicit names
and privacy-preserving resolution. Also, you should read the next
chapter of the tutorial and learn how to use GNS to have a
private conversation with your friend. Finally, help us
with the next GNUnet release for even more applications
using this new public key infrastructure.

@node First steps - Using GNUnet Conversation
@section First steps - Using GNUnet Conversation
@c %**end of header

First, you should launch the graphical user interface.  You can do
this from the command-line by typing

@example
$ gnunet-conversation-gtk
@end example

@menu
* Testing your Audio Equipment::
* GNS Zones::
@end menu

@node Testing your Audio Equipment
@subsection Testing your Audio Equipment
@c %**end of header

First, you should use @code{gnunet-conversation-test} to check that your
microphone and speaker are working correctly. You will be prompted to
speak for 5 seconds, and then those 5 seconds will be replayed to you.
The network is not involved in this test. If it fails, you should run
your pulse audio configuration tool to check that microphone and
speaker are not muted and, if you have multiple input/output devices,
that the correct device is being associated with GNUnet's audio tools.

@node GNS Zones
@subsection GNS Zones
@c %**end of header

@code{gnunet-conversation} uses GNS for addressing. This means that
you need to have a GNS zone created before using it. Information
about how to create GNS zones can be found here.


@menu
* Picking an Identity::
* Calling somebody::
@end menu

@node Picking an Identity
@subsubsection Picking an Identity
@c %**end of header

To make a call with @code{gnunet-conversation}, you first
need to choose an identity. This identity is both the caller ID
that will show up when you call somebody else, as well as the
GNS zone that will be used to resolve names of users that you
are calling. Run

@example
gnunet-conversation -e zone-name
@end example

@noindent
to start the command-line tool. You will see a message saying
that your phone is now "active on line 0". You can connect
multiple phones on different lines at the same peer. For the
first phone, the line zero is of course a fine choice.

Next, you should type in @command{/help} for a list of
available commands. We will explain the important ones
during this tutorial. First, you will need to type in
@command{/address} to determine the address of your
phone. The result should look something like this:

@example
/address
0-PD67SGHF3E0447TU9HADIVU9OM7V4QHTOG0EBU69TFRI2LG63DR0
@end example

@noindent
Here, the "0" is your phone line, and what follows
after the hyphen is your peer's identity. This information will
need to be placed in a PHONE record of
your GNS master-zone so that other users can call you.

Start @code{gnunet-namestore-gtk} now (possibly from another
shell) and create an entry home-phone in your master zone.
For the record type, select PHONE. You should then see the
PHONE dialog:

@c image here

Note: Do not choose the expiry time to be 'Never'. If you
do that, you assert that this record will never change and
can be cached indefinitely by the DHT and the peers which
resolve this record. A reasonable period is 1 year.

Enter your peer identity under Peer and leave the line
at zero. Select the first option to make the record public.
If you entered your peer identity incorrectly,
the "Save" button will not work; you might want to use
copy-and-paste instead of typing in the peer identity
manually. Save the record.

@node Calling somebody
@subsubsection Calling somebody
@c %**end of header

Now you can call a buddy. Obviously, your buddy will have to have GNUnet
installed and must have performed the same steps. Also, you must have
your buddy in your GNS master zone, for example by having imported
your buddy's public key using @code{gnunet-qr}. Suppose your buddy
is in your zone as @code{buddy.mytld} and they also created their
phone using a label "home-phone". Then you can initiate a call using:

@example
/call home-phone.buddy.mytld
@end example

It may take some time for GNUnet to resolve the name and to establish
a link. If your buddy has your public key in their master zone, they
should see an incoming call with your name. If your public key is not
in their master zone, they will just see the public key as the caller ID.

Your buddy then can answer the call using the "/accept" command. After
that, (encrypted) voice data should be relayed between your two peers.
Either of you can end the call using @command{/cancel}. You can exit
@code{gnunet-converation} using @command{/quit}.


@node First steps - Using the GNUnet VPN
@section First steps - Using the GNUnet VPN
@c %**end of header


@menu
* VPN Preliminaries::
* Exit configuration::
* GNS configuration::
* Accessing the service::
* Using a Browser::
@end menu

@node VPN Preliminaries
@subsection VPN Preliminaries
@c %**end of header

To test the GNUnet VPN, we should first run a web server.
The easiest way to do this is to just start @code{gnunet-bcd},
which will run a webserver on port @code{8888} by default.
Naturally, you can run some other HTTP server for our little tutorial.

If you have not done this, you should also configure your
Name System Service switch to use GNS. In your @code{/etc/nsswitch.conf}
you should fine a line like this:

@example
hosts: files mdns4_minimal [NOTFOUND=return] dns mdns4
@end example

@noindent
The exact details may differ a bit, which is fine. Add the text
@code{gns [NOTFOUND=return]} after @code{files}:

@example
hosts: files gns [NOTFOUND=return] mdns4_minimal [NOTFOUND=return] dns mdns4
@end example

@noindent
You might want to make sure that @code{/lib/libnss_gns.so.2} exists on
your system, it should have been created during the installation.
If not, re-run

@example
$ configure --with-nssdir=/lib
$ cd src/gns/nss; sudo make install
@end example

@noindent
to install the NSS plugins in the proper location.

@node Exit configuration
@subsection Exit configuration
@c %**end of header

Stop your peer (as user @code{gnunet}, run @command{gnunet-arm -e}) and
run @command{gnunet-setup}. In @command{gnunet-setup}, make sure to
activate the @strong{EXIT} and @strong{GNS} services in the General tab.
Then select the Exit tab. Most of the defaults should be fine (but
you should check against the screenshot that they have not been modified).
In the bottom area, enter @code{bcd} under Identifier and change the
Destination to @code{169.254.86.1:8888} (if your server runs on a port
other than 8888, change the 8888 port accordingly).

Now exit @command{gnunet-setup} and restart your peer
(@command{gnunet-arm -s}).

@node GNS configuration
@subsection GNS configuration
@c %**end of header

Now, using your normal user (not the @code{gnunet} system user), run
@command{gnunet-gtk}. Select the GNS icon and add a new label www in your
master zone. For the record type, select @code{VPN}. You should then
see the VPN dialog:

@c insert image

Under peer, you need to supply the peer identity of your own peer. You can
obtain the respective string by running @command{gnunet-peerinfo -sq}
as the @code{gnunet} user. For the Identifier, you need to supply the same
identifier that we used in the Exit setup earlier, so here supply "bcd".
If you want others to be able to use the service, you should probably make
the record public. For non-public services, you should use a passphrase
instead of the string "bcd". Save the record and
exit @command{gnunet-gtk}.

@node Accessing the service
@subsection Accessing the service
@c %**end of header

You should now be able to access your webserver. Type in:

@example
$ wget http://www.gnu/
@end example

@noindent
The request will resolve to the VPN record, telling the GNS resolver
to route it via the GNUnet VPN. The GNS resolver will ask the
GNUnet VPN for an IPv4 address to return to the application. The
VPN service will use the VPN information supplied by GNS to create
a tunnel (via GNUnet's MESH service) to the EXIT peer.
At the EXIT, the name "bcd" and destination port (80) will be mapped
to the specified destination IP and port. While all this is currently
happening on just the local machine, it should also work with other
peers --- naturally, they will need a way to access your GNS zone
first, for example by learning your public key from a QR code on
your business card.

@node Using a Browser
@subsection Using a Browser
@c %**end of header

Sadly, modern browsers tend to bypass the Name Services Switch and
attempt DNS resolution directly. You can either run
a @code{gnunet-dns2gns} DNS proxy, or point the browsers to an
HTTP proxy. When we tried it, Iceweasel did not like to connect to
the socks proxy for @code{.gnu} TLDs, even if we disabled its
autoblunder of changing @code{.gnu} to ".gnu.com". Still,
using the HTTP proxy with Chrome does work.

@node File-sharing
@section File-sharing
@c %**end of header

This chapter documents the GNUnet file-sharing application. The original
file-sharing implementation for GNUnet was designed to provide
@strong{anonymous} file-sharing. However, over time, we have also added
support for non-anonymous file-sharing (which can provide better
performance). Anonymous and non-anonymous file-sharing are quite
integrated in GNUnet and, except for routing, share most of the concepts
and implementation. There are three primary file-sharing operations:
publishing, searching and downloading. For each of these operations,
the user specifies an @strong{anonymity level}. If both the publisher and
the searcher/downloader specify "no anonymity", non-anonymous
file-sharing is used. If either user specifies some desired degree
of anonymity, anonymous file-sharing will be used.

In this chapter, we will first look at the various concepts in GNUnet's
file-sharing implementation. Then, we will discuss specifics as to
how they impact users that publish, search or download files.



@menu
* File-sharing Concepts::
* File-sharing Publishing::
* File-sharing Searching::
* File-sharing Downloading::
* File-sharing Directories::
* File-sharing Namespace Management::
* File-Sharing URIs::
@end menu

@node File-sharing Concepts
@subsection File-sharing Concepts
@c %**end of header

Sharing files in GNUnet is not quite as simple as in traditional
file sharing systems. For example, it is not sufficient to just
place files into a specific directory to share them. In addition
to anonymous routing GNUnet attempts to give users a better experience
in searching for content. GNUnet uses cryptography to safely break
content into smaller pieces that can be obtained from different
sources without allowing participants to corrupt files. GNUnet
makes it difficult for an adversary to send back bogus search
results. GNUnet enables content providers to group related content
and to establish a reputation. Furthermore, GNUnet allows updates
to certain content to be made available. This section is supposed
to introduce users to the concepts that are used to achive these goals.


@menu
* Files::
* Keywords::
* Directories::
* Pseudonyms::
* Namespaces::
* Advertisements::
* Anonymity level::
* Content Priority::
* Replication::
@end menu

@node Files
@subsubsection Files
@c %**end of header

A file in GNUnet is just a sequence of bytes. Any file-format is allowed
and the maximum file size is theoretically 264 bytes, except that it
would take an impractical amount of time to share such a file.
GNUnet itself never interprets the contents of shared files, except
when using GNU libextractor to obtain keywords.

@node Keywords
@subsubsection Keywords
@c %**end of header

Keywords are the most simple mechanism to find files on GNUnet.
Keywords are @strong{case-sensitive} and the search string
must always match @strong{exactly} the keyword used by the
person providing the file. Keywords are never transmitted in
plaintext. The only way for an adversary to determine the keyword
that you used to search is to guess it (which then allows the
adversary to produce the same search request). Since providing
keywords by hand for each shared file is tedious, GNUnet uses
GNU libextractor to help automate this process. Starting a
keyword search on a slow machine can take a little while since
the keyword search involves computing a fresh RSA key to formulate the
request.

@node Directories
@subsubsection Directories
@c %**end of header

A directory in GNUnet is a list of file identifiers with meta data.
The file identifiers provide sufficient information about the files
to allow downloading the contents. Once a directory has been created,
it cannot be changed since it is treated just like an ordinary file
by the network. Small files (of a few kilobytes) can be inlined in
the directory, so that a separate download becomes unnecessary.

@node Pseudonyms
@subsubsection Pseudonyms
@c %**end of header

Pseudonyms in GNUnet are essentially public-private (RSA) key pairs
that allow a GNUnet user to maintain an identity (which may or may not
be detached from their real-life identity). GNUnet's pseudonyms are not
file-sharing specific --- and they will likely be used by many GNUnet
applications where a user identity is required.

Note that a pseudonym is NOT bound to a GNUnet peer. There can be multiple
pseudonyms for a single user, and users could (theoretically) share the
private pseudonym keys (currently only out-of-band by knowing which files
to copy around).

@node Namespaces
@subsubsection Namespaces
@c %**end of header

A namespace is a set of files that were signed by the same pseudonym.
Files (or directories) that have been signed and placed into a namespace
can be updated. Updates are identified as authentic if the same secret
key was used to sign the update. Namespaces are also useful to establish
a reputation, since all of the content in the namespace comes from the
same entity (which does not have to be the same person).

@node Advertisements
@subsubsection Advertisements
@c %**end of header

Advertisements are used to notify other users about the existence of a
namespace. Advertisements are propagated using the normal keyword search.
When an advertisement is received (in response to a search), the namespace
is added to the list of namespaces available in the namespace-search
dialogs of gnunet-fs-gtk and printed by gnunet-pseudonym. Whenever a
namespace is created, an appropriate advertisement can be generated.
The default keyword for the advertising of namespaces is "namespace".

Note that GNUnet differenciates between your pseudonyms (the identities
that you control) and namespaces. If you create a pseudonym, you will
not automatically see the respective namespace. You first have to create
an advertisement for the namespace and find it using keyword
search --- even for your own namespaces. The @command{gnunet-pseudonym}
tool is currently responsible for both managing pseudonyms and namespaces.
This will likely change in the future to reduce the potential for
confusion.

@node Anonymity level
@subsubsection Anonymity level
@c %**end of header

The anonymity level determines how hard it should be for an adversary to
determine the identity of the publisher or the searcher/downloader. An
anonymity level of zero means that anonymity is not required. The default
anonymity level of "1" means that anonymous routing is desired, but no
particular amount of cover traffic is necessary. A powerful adversary
might thus still be able to deduce the origin of the traffic using
traffic analysis. Specifying higher anonymity levels increases the
amount of cover traffic required. While this offers better privacy,
it can also significantly hurt performance.

@node Content Priority
@subsubsection Content Priority
@c %**end of header

Depending on the peer's configuration, GNUnet peers migrate content
between peers. Content in this sense are individual blocks of a file,
not necessarily entire files. When peers run out of space (due to
local publishing operations or due to migration of content from other
peers), blocks sometimes need to be discarded. GNUnet first always
discards expired blocks (typically, blocks are published with an
expiration of about two years in the future; this is another option).
If there is still not enough space, GNUnet discards the blocks with the
lowest priority. The priority of a block is decided by its popularity
(in terms of requests from peers we trust) and, in case of blocks
published locally, the base-priority that was specified by the user
when the block was published initially.

@node Replication
@subsubsection Replication
@c %**end of header

When peers migrate content to other systems, the replication level
of a block is used to decide which blocks need to be migrated most
urgently. GNUnet will always push the block with the highest
replication level into the network, and then decrement the replication
level by one. If all blocks reach replication level zero, the
selection is simply random.

@node File-sharing Publishing
@subsection File-sharing Publishing
@c %**end of header

The command @command{gnunet-publish} can be used to add content
to the network. The basic format of the command is

@example
$ gnunet-publish [-n] [-k KEYWORDS]* [-m TYPE:VALUE] FILENAME
@end example


@menu
* Important command-line options::
* Indexing vs. Inserting::
@end menu

@node Important command-line options
@subsubsection Important command-line options
@c %**end of header

The option -k is used to specify keywords for the file that
should be inserted. You can supply any number of keywords,
and each of the keywords will be sufficient to locate and
retrieve the file.

The -m option is used to specify meta-data, such as descriptions.
You can use -m multiple times. The TYPE passed must be from the
list of meta-data types known to libextractor. You can obtain this
list by running @command{extract -L}. Use quotes around the entire
meta-data argument if the value contains spaces. The meta-data
is displayed to other users when they select which files to
download. The meta-data and the keywords are optional and
maybe inferred using @code{GNU libextractor}.

gnunet-publish has a few additional options to handle namespaces and
directories. See the man-page for details.

@node Indexing vs. Inserting
@subsubsection Indexing vs Inserting
@c %**end of header

By default, GNUnet indexes a file instead of making a full copy.
This is much more efficient, but requries the file to stay unaltered
at the location where it was when it was indexed. If you intend to move,
delete or alter a file, consider using the option @code{-n} which will
force GNUnet to make a copy of the file in the database.

Since it is much less efficient, this is strongly discouraged for large
files. When GNUnet indexes a file (default), GNUnet does @strong{not}
create an additional encrypted copy of the file but just computes a
summary (or index) of the file. That summary is approximately two percent
of the size of the original file and is stored in GNUnet's database.
Whenever a request for a part of an indexed file reaches GNUnet,
this part is encrypted on-demand and send out. This way, there is no
need for an additional encrypted copy of the file to stay anywhere
on the drive. This is different from other systems, such as Freenet,
where each file that is put online must be in Freenet's database in
encrypted format, doubling the space requirements if the user wants
to preseve a directly accessible copy in plaintext.

Thus indexing should be used for all files where the user will keep
using this file (at the location given to gnunet-publish) and does
not want to retrieve it back from GNUnet each time. If you want to
remove a file that you have indexed from the local peer, use the tool
@command{gnunet-unindex} to un-index the file.

The option @code{-n} may be used if the user fears that the file might
be found on their drive (assuming the computer comes under the control
of an adversary). When used with the @code{-n} flag, the user has a
much better chance of denying knowledge of the existence of the file,
even if it is still (encrypted) on the drive and the adversary is
able to crack the encryption (e.g. by guessing the keyword.

@node File-sharing Searching
@subsection File-sharing Searching
@c %**end of header

The command @command{gnunet-search} can be used to search
for content on GNUnet. The format is:

@example
$ gnunet-search [-t TIMEOUT] KEYWORD
@end example

@noindent
The -t option specifies that the query should timeout after
approximately TIMEOUT seconds. A value of zero is interpreted
as @emph{no timeout}, which is also the default. In this case,
gnunet-search will never terminate (unless you press CTRL-C).

If multiple words are passed as keywords, they will all be
considered optional. Prefix keywords with a "+" to make them mandatory.

Note that searching using

@example
$ gnunet-search Das Kapital
@end example

@noindent
is not the same as searching for

@example
$ gnunet-search "Das Kapital"
@end example

@noindent
as the first will match files shared under the keywords
"Das" or "Kapital" whereas the second will match files
shared under the keyword "Das Kapital".

Search results are printed by gnunet-search like this:

@c it will be better the avoid the ellipsis altogether because I don't
@c understand the explanation below that
@example
$ gnunet-download -o "COPYING" --- gnunet://fs/chk/N8...C92.17992
=> The GNU Public License <= (mimetype: text/plain)
@end example

@noindent
The first line is the command you would have to enter to download
the file. The argument passed to @code{-o} is the suggested
filename (you may change it to whatever you like).
@c except it's triple dash in the above example ---
The @code{--} is followed by key for decrypting the file,
the query for searching the file, a checksum (in hexadecimal)
finally the size of the file in bytes.
The second line contains the description of the file; here this is
"The GNU Public License" and the mime-type (see the options for
gnunet-publish on how to specify these).

@node File-sharing Downloading
@subsection File-sharing Downloading
@c %**end of header

In order to download a file, you need the three values returned by
@command{gnunet-search}.
You can then use the tool @command{gnunet-download} to obtain the file:

@example
$ gnunet-download -o FILENAME --- GNUNETURL
@end example

@noindent
FILENAME specifies the name of the file where GNUnet is supposed
to write the result. Existing files are overwritten. If the
existing file contains blocks that are identical to the
desired download, those blocks will not be downloaded again
(automatic resume).

If you want to download the GPL from the previous example,
you do the following:

@example
$ gnunet-download -o "COPYING" --- gnunet://fs/chk/N8...92.17992
@end example

@noindent
If you ever have to abort a download, you can continue it at any time by
re-issuing @command{gnunet-download} with the same filename.
In that case, GNUnet will @strong{not} download blocks again that are
already present.

GNUnet's file-encoding mechanism will ensure file integrity, even if the
existing file was not downloaded from GNUnet in the first place.

You may want to use the @command{-V} switch (must be added before
@c Same as above it's triple dash
the @command{--}) to turn on verbose reporting. In this case,
@command{gnunet-download} will print the current number of
bytes downloaded whenever new data was received.

@node File-sharing Directories
@subsection File-sharing Directories
@c %**end of header

Directories are shared just like ordinary files. If you download a
directory with @command{gnunet-download}, you can use
@command{gnunet-directory} to list its contents. The canonical
extension for GNUnet directories when stored as files in your
local file-system is ".gnd". The contents of a directory are URIs and
meta data.
The URIs contain all the information required by
@command{gnunet-download} to retrieve the file. The meta data
typically includes the mime-type, description, a filename and
other meta information, and possibly even the full original file
(if it was small).

@node File-sharing Namespace Management
@subsection File-sharing Namespace Management
@c %**end of header

@b{Please note that the text in this subsection is outdated and needs}
@b{to be rewritten for version 0.10!}

The gnunet-pseudonym tool can be used to create pseudonyms and
to advertise namespaces. By default, gnunet-pseudonym simply
lists all locally available pseudonyms.


@menu
* Creating Pseudonyms::
* Deleting Pseudonyms::
* Advertising namespaces::
* Namespace names::
* Namespace root::
@end menu

@node Creating Pseudonyms
@subsubsection Creating Pseudonyms
@c %**end of header

With the @command{-C NICK} option it can also be used to
create a new pseudonym. A pseudonym is the virtual identity
of the entity in control of a namespace. Anyone can create
any number of pseudonyms. Note that creating a pseudonym can
take a few minutes depending on the performance of the machine
used.

@node Deleting Pseudonyms
@subsubsection Deleting Pseudonyms
@c %**end of header

With the @command{-D NICK} option pseudonyms can be deleted.
Once the pseudonym has been deleted it is impossible to add
content to the corresponding namespace. Deleting the
pseudonym does not make the namespace or any content in it
unavailable.

@node Advertising namespaces
@subsubsection Advertising namespaces
@c %**end of header

Each namespace is associated with meta-data that describes
the namespace. This meta-data is provided by the user at
the time that the namespace is advertised. Advertisements
are published under keywords so that they can be found using
normal keyword-searches. This way, users can learn about new
namespaces without relying on out-of-band communication or directories.
A suggested keyword to use for all namespaces is simply "namespace".
When a keyword-search finds a namespace advertisement,
it is automatically stored in a local list of known namespaces.
Users can then associate a rank with the namespace to remember
the quality of the content found in it.

@node Namespace names
@subsubsection Namespace names
@c %**end of header

While the namespace is uniquely identified by its ID, another way
to refer to the namespace is to use the NICKNAME.
The NICKNAME can be freely chosen by the creator of the namespace and
hence conflicts are possible. If a GNUnet client learns about more
than one namespace using the same NICKNAME, the ID is appended
to the NICKNAME to get a unique identifier.

@node Namespace root
@subsubsection Namespace root
@c %**end of header

An item of particular interest in the namespace advertisement is
the ROOT. The ROOT is the identifier of a designated entry in the
namespace. The idea is that the ROOT can be used to advertise an
entry point to the content of the namespace.

@node File-Sharing URIs
@subsection File-Sharing URIs
@c %**end of header

GNUnet (currently) uses four different types of URIs for
file-sharing. They all begin with "gnunet://fs/".
This section describes the four different URI types in detail.

For FS URIs empty KEYWORDs are not allowed. Quotes are allowed to
denote whitespace between words. Keywords must contain a balanced
number of double quotes. Doubles quotes can not be used in the actual
keywords. This means that the the string '""foo bar""' will be turned
into two OR-ed keywords 'foo' and 'bar', not into '"foo bar"'.

@menu
* Encoding of hash values in URIs::
* Content Hash Key (chk)::
* Location identifiers (loc)::
* Keyword queries (ksk)::
* Namespace content (sks)::
@end menu

@node Encoding of hash values in URIs
@subsubsection Encoding of hash values in URIs
@c %**end of header

Most URIs include some hash values. Hashes are encoded using
base32hex (RFC 2938).

@cindex chk-uri
@node Content Hash Key (chk)
@subsubsection Content Hash Key (chk)
@c %**end of header

A chk-URI is used to (uniquely) identify a file or directory
and to allow peers to download the file. Files are stored in
GNUnet as a tree of encrypted blocks.
The chk-URI thus contains the information to download and decrypt
those blocks. A chk-URI has the format
"gnunet://fs/chk/KEYHASH.QUERYHASH.SIZE". Here, "SIZE"
is the size of the file (which allows a peer to determine the
shape of the tree), KEYHASH is the key used to decrypt the file
(also the hash of the plaintext of the top block) and QUERYHASH
is the query used to request the top-level block (also the hash
of the encrypted block).

@cindex loc-uri
@node Location identifiers (loc)
@subsubsection Location identifiers (loc)
@c %**end of header

For non-anonymous file-sharing, loc-URIs are used to specify which
peer is offering the data (in addition to specifying all of the
data from a chk-URI). Location identifiers include a digital
signature of the peer to affirm that the peer is truly the
origin of the data. The format is
"gnunet://fs/loc/KEYHASH.QUERYHASH.SIZE.PEER.SIG.EXPTIME".
Here, "PEER" is the public key of the peer (in GNUnet format in
base32hex), SIG is the RSA signature (in GNUnet format in
base32hex) and EXPTIME specifies when the signature expires
(in milliseconds after 1970).

@cindex ksk-uri
@node Keyword queries (ksk)
@subsubsection Keyword queries (ksk)
@c %**end of header

A keyword-URI is used to specify that the desired operation
is the search using a particular keyword. The format is simply
"gnunet://fs/ksk/KEYWORD". Non-ASCII characters can be specified
using the typical URI-encoding (using hex values) from HTTP.
"+" can be used to specify multiple keywords (which are then
logically "OR"-ed in the search, results matching both keywords
are given a higher rank): "gnunet://fs/ksk/KEYWORD1+KEYWORD2".
ksk-URIs must not begin or end with the plus ('+') character.
Furthermore they must not contain '++'.

@cindex sks-uri
@node Namespace content (sks)
@subsubsection Namespace content (sks)
@c %**end of header

Namespaces are sets of files that have been approved by some (usually
pseudonymous) user --- typically by that user publishing all of the
files together. A file can be in many namespaces. A file is in a
namespace if the owner of the ego (aka the namespace's private key)
signs the CHK of the file cryptographically. An SKS-URI is used to
search a namespace. The result is a block containing meta data,
the CHK and the namespace owner's signature. The format of a sks-URI
is "gnunet://fs/sks/NAMESPACE/IDENTIFIER". Here, "NAMESPACE"
is the public key for the namespace. "IDENTIFIER" is a freely
chosen keyword (or password!). A commonly used identifier is
"root" which by convention refers to some kind of index or other
entry point into the namespace.

@node The GNU Name System
@section The GNU Name System
@c %**end of header


The GNU Name System (GNS) is secure and decentralized naming system.
It allows its users to resolve and register names within the @code{.gnu}
@dfn{top-level domain} (TLD).

GNS is designed to provide:
@itemize @bullet
@item Censorship resistance
@item Query privacy
@item Secure name resolution
@item Compatibility with DNS
@end itemize

For the initial configuration and population of your
GNS installation, please follow the GNS setup instructions.
The remainder of this chapter will provide some background on GNS
and then describe how to use GNS in more detail.

Unlike DNS, GNS does not rely on central root zones or authorities.
Instead any user administers their own root and can can create arbitrary
name value mappings. Furthermore users can delegate resolution to other
users' zones just like DNS NS records do. Zones are uniquely identified
via public keys and resource records are signed using the corresponding
public key. Delegation to another user's zone is done using special PKEY
records and petnames. A petname is a name that can be freely chosen by
the user. This results in non-unique name-value mappings as
@code{@uref{http://www.bob.gnu/, www.bob.gnu}} to one user might be
@code{@uref{http://www.friend.gnu/, www.friend.gnu}} for someone else.


@menu
* Creating a Zone::
* Maintaining your own Zones::
* Obtaining your Zone Key::
* Adding Links to Other Zones::
* Using Public Keys as Top Level Domains::
* Resource Records in GNS::
* Synchronizing with legacy DNS::
@end menu


@node Creating a Zone
@subsection Creating a Zone

To use GNS, you probably should create at least one zone of your own.
You can create any number of zones using the gnunet-identity tool
using:

@example
$ gnunet-identity -C "myzone"
@end example

Henceforth, on your system you control the TLD ``myzone''.

All of your zones can be listed using the @command{gnunet-identity}
command line tool as well:

@example
$ gnunet-identity -d
@end example

@node Maintaining your own Zones
@subsection Maintaining your own Zones

@noindent
Now you can add (or edit, or remove) records in your GNS zone using the
@command{gnunet-namestore-gtk} GUI or using the @command{gnunet-namestore}
command-line tool.
In either case, your records will be stored in an SQL database under
control of the @command{gnunet-service-namestore}.
Note that if multiple users use one peer, the namestore database will
include the combined records of all users.
However, users will not be able to see each other's records
if they are marked as private.

To provide a short example for editing your own zone, suppose you
have your own web server with the IP @code{1.2.3.4}. Then you can put an
@code{A} record (@code{A} records in DNS are for IPv4 IP addresses)
into your local zone ``myzone'' using the command:

@example
$ gnunet-namestore -z myzone -a -n www -t A -V 1.2.3.4 -e never
@end example

@noindent
Afterwards, you will be able to access your webpage under "www.myzone"
(assuming your webserver does not use virtual hosting, if it does,
please read up on setting up the GNS proxy).

Similar commands will work for other types of DNS and GNS records,
the syntax largely depending on the type of the record.
Naturally, most users may find editing the zones using the
@command{gnunet-namestore-gtk} GUI to be easier.

@node Obtaining your Zone Key
@subsection Obtaining your Zone Key

Each zone in GNS has a public-private key. Usually, gnunet-namestore and
gnunet-setup will access your private key as necessary, so you do not
have to worry about those. What is important is your public key
(or rather, the hash of your public key), as you will likely want to
give it to others so that they can securely link to you.

You can usually get the hash of your public key using

@example
$ gnunet-identity -d $options | grep myzone | awk '@{print $3@}'
@end example

@noindent
For example, the output might be something like:

@example
DC3SEECJORPHQNVRH965A6N74B1M37S721IG4RBQ15PJLLPJKUE0
@end example

@noindent
Alternatively, you can obtain a QR code with your zone key AND your
pseudonym from gnunet-namestore-gtk. The QR code is displayed in the
main window and can be stored to disk using the ``Save as'' button
next to the image.

@node Adding Links to Other Zones
@subsection Adding Links to Other Zones


A central operation in GNS is the ability to securely delegate to
other zones. Basically, by adding a delegation you make all of the
names from the other zone available to yourself. This section
describes how to create delegations.

Suppose you have a friend who you call 'bob' who also uses GNS.
You can then delegate resolution of names to Bob's zone by adding
a PKEY record to their local zone:

@example
$ gnunet-namestore -a -n bob --type PKEY -V XXXX -e never -Z myzone
@end example

@noindent
Note that ``XXXX'' in the command above must be replaced with the hash
of Bob's public key (the output your friend obtained using the
@command{gnunet-identity} command from the previous section and told
you, for example by giving you a business card containing this
information as a QR code).

Assuming Bob has an ``A'' record for their website under the name of
``www'' in his zone, you can then access Bob's website under
``www.bob.myzone'' --- as well as any (public) GNS record that Bob has
in their zone by replacing www with the respective name of the
record in Bob's zone.

@c themselves? themself?
Furthermore, if Bob has themselves a (public) delegation to Carol's
zone under "carol", you can access Carol's records under
``NAME.carol.bob.myzone'' (where ``NAME'' is the name of Carol's
record you want to access).


@node Using Public Keys as Top Level Domains
@subsection Using Public Keys as Top Level Domains


GNS also assumes responsibility for any name that uses in a well-formed
public key for the TLD.  Names ending this way are then resolved by querying
the respective zone. Such public key TLDs are expected to be used under rare
circumstances where globally unique names are required, and for
integration with legacy systems.

@node Resource Records in GNS
@subsection Resource Records in GNS


GNS supports the majority of the DNS records as defined in
@uref{http://www.ietf.org/rfc/rfc1035.txt, RFC 1035}. Additionally,
GNS defines some new record types the are unique to the GNS system.
For example, GNS-specific resource records are used to give petnames
for zone delegation, revoke zone keys and provide some compatibility
features.

For some DNS records, GNS does extended processing to increase their
usefulness in GNS. In particular, GNS introduces special names
referred to as "zone relative names". Zone relative names are allowed
in some resource record types (for example, in NS and CNAME records)
and can also be used in links on webpages. Zone relative names end
in ".+" which indicates that the name needs to be resolved relative
to the current authoritative zone. The extended processing of those
names will expand the ".+" with the correct delegation chain to the
authoritative zone (replacing ".+" with the name of the location
where the name was encountered) and hence generate a
valid GNS name.

GNS currently supports the following record types:

@menu
* NICK::
* PKEY::
* BOX::
* LEHO::
* VPN::
* A AAAA and TXT::
* CNAME::
* GNS2DNS::
* SOA SRV PTR and MX::
@end menu

@node NICK
@subsubsection NICK

A NICK record is used to give a zone a name. With a NICK record, you can
essentially specify how you would like to be called. GNS expects this
record under the empty label ``@@'' in the zone's database (NAMESTORE); however,
it will then automatically be copied into each record set, so that
clients never need to do a separate lookup to discover the NICK record.
Also, users do not usually have to worry about setting the NICK record:
it is automatically set to the local name of the TLD.

@b{Example}@

@example
Name: @@; RRType: NICK; Value: bob
@end example

@noindent
This record in Bob's zone will tell other users that this zone wants
to be referred to as 'bob'. Note that nobody is obliged to call Bob's
zone 'bob' in their own zones. It can be seen as a
recommendation ("Please call this zone 'bob'").

@node PKEY
@subsubsection PKEY

PKEY records are used to add delegation to other users' zones and
give those zones a petname.

@b{Example}@

Let Bob's zone be identified by the hash "ABC012". Bob is your friend
so you want to give them the petname "friend". Then you add the
following record to your zone:

@example
Name: friend; RRType: PKEY; Value: ABC012;
@end example

@noindent
This will allow you to resolve records in bob's zone
under "*.friend.gnu".

@node BOX
@subsubsection BOX

BOX records are there to integrate information from TLSA or
SRV records under the main label. In DNS, TLSA and SRV records
use special names of the form @code{_port._proto.(label.)*tld} to
indicate the port number and protocol (i.e. tcp or udp) for which
the TLSA or SRV record is valid. This causes various problems, and
is elegantly solved in GNS by integrating the protocol and port
numbers together with the respective value into a "BOX" record.
Note that in the GUI, you do not get to edit BOX records directly
right now --- the GUI will provide the illusion of directly
editing the TLSA and SRV records, even though they internally
are BOXed up.

@node LEHO
@subsubsection LEHO

The LEgacy HOstname of a server. Some webservers expect a specific
hostname to provide a service (virtiual hosting). Also SSL
certificates usually contain DNS names. To provide the expected
legacy DNS name for a server, the LEHO record can be used.
To mitigate the just mentioned issues the GNS proxy has to be used.
The GNS proxy will use the LEHO information to apply the necessary
transformations.

@node VPN
@subsubsection VPN

GNS allows easy access to services provided by the GNUnet Virtual Public
Network. When the GNS resolver encounters a VPN record it will contact
the VPN service to try and allocate an IPv4/v6 address (if the queries
record type is an IP address) that can be used to contact the service.

@b{Example}@

I want to provide access to the VPN service "web.gnu." on port 80 on peer
ABC012:@
Name: www; RRType: VPN; Value: 80 ABC012 web.gnu.

The peer ABC012 is configured to provide an exit point for the service
"web.gnu." on port 80 to it's server running locally on port 8080 by
having the following lines in the @file{gnunet.conf} configuration file:

@example
[web.gnunet.]
TCP_REDIRECTS = 80:localhost4:8080
@end example

@node A AAAA and TXT
@subsubsection A AAAA and TXT

Those records work in exactly the same fashion as in traditional DNS.

@node CNAME
@subsubsection CNAME

As specified in RFC 1035 whenever a CNAME is encountered the query
needs to be restarted with the specified name. In GNS a CNAME
can either be:

@itemize @bullet
@item A zone relative name,
@item A zkey name or
@item A DNS name (in which case resolution will continue outside
of GNS with the systems DNS resolver)
@end itemize

@node GNS2DNS
@subsubsection GNS2DNS

GNS can delegate authority to a legacy DNS zone. For this, the
name of the DNS nameserver and the name of the DNS zone are
specified in a GNS2DNS record.

@b{Example}

@example
Name: pet; RRType: GNS2DNS; Value: gnunet.org@@a.ns.joker.com
@end example

@noindent
Any query to @code{pet.gnu} will then be delegated to the DNS server at
@code{a.ns.joker.com}. For example,
@code{@uref{http://www.pet.gnu/, www.pet.gnu}} will result in a DNS query
for @code{@uref{http://www.gnunet.org/, www.gnunet.org}} to the server
at @code{a.ns.joker.com}. Delegation to DNS via NS records in GNS can
be useful if you do not want to start resolution in the DNS root zone
(due to issues such as censorship or availability).

Note that you would typically want to use a relative name for the
nameserver, i.e.

@example
Name: pet; RRType: GNS2DNS; Value: gnunet.org@@ns-joker.+@
Name: ns-joker; RRType: A; Value: 184.172.157.218
@end example

@noindent
This way, you can avoid involving the DNS hierarchy in the resolution of
@code{a.ns.joker.com}. In the example above, the problem may not be
obvious as the nameserver for "gnunet.org" is in the ".com" zone.
However, imagine the nameserver was "ns.gnunet.org". In this case,
delegating to "ns.gnunet.org" would mean that despite using GNS,
censorship in the DNS ".org" zone would still be effective.

@node SOA SRV PTR and MX
@subsubsection SOA SRV PTR and MX

The domain names in those records can, again, be either

@itemize @bullet
@item A zone relative name,
@item A zkey name or
@item A DNS name
@end itemize

The resolver will expand the zone relative name if possible.
Note that when using MX records within GNS, the target mail
server might still refuse to accept e-mails to the resulting
domain as the name might not match. GNS-enabled mail clients
should use the ZKEY zone as the destination hostname and
GNS-enabled mail servers should be configured to accept
e-mails to the ZKEY-zones of all local users.

@node Synchronizing with legacy DNS
@subsection Synchronizing with legacy DNS

If you want to support GNS but the master database for a zone
is only available and maintained in DNS, GNUnet includes the
@command{gnunet-zoneimport} tool to monitor a DNS zone and
automatically import records into GNS.  Today, the tool does
not yet support DNS AF(X)R, as we initially used it on the
``.fr'' zone which does not allow us to perform a DNS zone
transfer.  Instead, @command{gnunet-zoneimport} reads a list
of DNS domain names from @code{stdin}, issues DNS queries for
each, converts the obtained records (if possible) and stores
the result in the namestore.

@image{images/gns,6in,, picture of DNS-GNS data flow}

The zonemaster service then takes the records from the namestore,
publishes them into the DHT which makes the result available to the
GNS resolver.  In the GNS configuration, non-local zones can be
configured to be intercepted by specifying ``.tld = PUBLICKEY'' in the
configuration file in the ``[gns]'' section.

Note that the namestore by default also populates the namecache.
This pre-population is cryptographically expensive. Thus, on
systems that only serve to import a large (millions of records)
DNS zone and that do not have a local gns service in use, it
is thus advisable to disable the namecache by setting the
option ``DISABLE'' to ``YES'' in section ``[namecache]''.


@node Using the Virtual Public Network
@section Using the Virtual Public Network

@menu
* Setting up an Exit node::
* Fedora and the Firewall::
* Setting up VPN node for protocol translation and tunneling::
@end menu

Using the GNUnet Virtual Public Network (VPN) application you can
tunnel IP traffic over GNUnet. Moreover, the VPN comes
with built-in protocol translation and DNS-ALG support, enabling
IPv4-to-IPv6 protocol translation (in both directions).
This chapter documents how to use the GNUnet VPN.

The first thing to note about the GNUnet VPN is that it is a public
network. All participating peers can participate and there is no
secret key to control access. So unlike common virtual private
networks, the GNUnet VPN is not useful as a means to provide a
"private" network abstraction over the Internet. The GNUnet VPN
is a virtual network in the sense that it is an overlay over the
Internet, using its own routing mechanisms and can also use an
internal addressing scheme. The GNUnet VPN is an Internet
underlay --- TCP/IP applications run on top of it.

The VPN is currently only supported on GNU/Linux systems.
Support for operating systems that support TUN (such as FreeBSD)
should be easy to add (or might not even require any coding at
all --- we just did not test this so far). Support for other
operating systems would require re-writing the code to create virtual
network interfaces and to intercept DNS requests.

The VPN does not provide good anonymity. While requests are routed
over the GNUnet network, other peers can directly see the source
and destination of each (encapsulated) IP packet. Finally, if you
use the VPN to access Internet services, the peer sending the
request to the Internet will be able to observe and even alter
the IP traffic. We will discuss additional security implications
of using the VPN later in this chapter.

@node Setting up an Exit node
@subsection Setting up an Exit node

Any useful operation with the VPN requires the existence of an exit
node in the GNUnet Peer-to-Peer network. Exit functionality can only
be enabled on peers that have regular Internet access. If you want
to play around with the VPN or support the network, we encourage
you to setup exit nodes. This chapter documents how to setup an
exit node.

There are four types of exit functions an exit node can provide,
and using the GNUnet VPN to access the Internet will only work
nicely if the first three types are provided somewhere in
the network. The four exit functions are:

@itemize @bullet
@item DNS: allow other peers to use your DNS resolver
@item IPv4: allow other peers to access your IPv4 Internet connection
@item IPv6: allow other peers to access your IPv6 Internet connection
@item Local service: allow other peers to access a specific TCP or
UDP service your peer is providing
@end itemize

By enabling "exit" in gnunet-setup and checking the respective boxes
in the "exit" tab, you can easily choose which of the above exit
functions you want to support.

Note, however, that by supporting the first three functions you will
allow arbitrary other GNUnet users to access the Internet via your
system. This is somewhat similar to running a Tor exit node. The
Torproject has a nice article about what to consider if you want
to do this here. We believe that generally running a DNS exit node
is completely harmless.

The exit node configuration does currently not allow you to restrict the
Internet traffic that leaves your system. In particular, you cannot
exclude SMTP traffic (or block port 25) or limit to HTTP traffic using
the GNUnet configuration. However, you can use your host firewall to
restrict outbound connections from the virtual tunnel interface. This
is highly recommended. In the future, we plan to offer a wider range
of configuration options for exit nodes.

Note that by running an exit node GNUnet will configure your kernel
to perform IP-forwarding (for IPv6) and NAT (for IPv4) so that the
traffic from the virtual interface can be routed to the Internet.
In order to provide an IPv6-exit, you need to have a subnet routed
to your host's external network interface and assign a subrange of
that subnet to the GNUnet exit's TUN interface.

When running a local service, you should make sure that the local
service is (also) bound to the IP address of your EXIT interface
(i.e. 169.254.86.1). It will NOT work if your local service is
just bound to loopback. You may also want to create a "VPN" record
in your zone of the GNU Name System to make it easy for others to
access your service via a name instead of just the full service
descriptor. Note that the identifier you assign the service can
serve as a passphrase or shared secret, clients connecting to the
service must somehow learn the service's name. VPN records in the
GNU Name System can make this easier.

@node Fedora and the Firewall
@subsection Fedora and the Firewall


When using an exit node on Fedora 15, the standard firewall can
create trouble even when not really exiting the local system!
For IPv4, the standard rules seem fine. However, for IPv6 the
standard rules prohibit traffic from the network range of the
virtual interface created by the exit daemon to the local IPv6
address of the same interface (which is essentially loopback
traffic, so you might suspect that a standard firewall would
leave this traffic alone). However, as somehow for IPv6 the
traffic is not recognized as originating from the local
system (and as the connection is not already "established"),
the firewall drops the traffic. You should still get ICMPv6
packets back, but that's obviously not very useful.

Possible ways to fix this include disabling the firewall (do you
have a good reason for having it on?) or disabling the firewall
at least for the GNUnet exit interface (or the respective
IPv4/IPv6 address range). The best way to diagnose these kinds
of problems in general involves setting the firewall to REJECT
instead of DROP and to watch the traffic using wireshark
(or tcpdump) to see if ICMP messages are generated when running
some tests that should work.

@node Setting up VPN node for protocol translation and tunneling
@subsection Setting up VPN node for protocol translation and tunneling


The GNUnet VPN/PT subsystem enables you to tunnel IP traffic over the
VPN to an exit node, from where it can then be forwarded to the
Internet. This section documents how to setup VPN/PT on a node.
Note that you can enable both the VPN and an exit on the same peer.
In this case, IP traffic from your system may enter your peer's VPN
and leave your peer's exit. This can be useful as a means to do
protocol translation. For example, you might have an application that
supports only IPv4 but needs to access an IPv6-only site. In this case,
GNUnet would perform 4to6 protocol translation between the VPN (IPv4)
and the Exit (IPv6). Similarly, 6to4 protocol translation is also
possible. However, the primary use for GNUnet would be to access
an Internet service running with an IP version that is not supported
by your ISP. In this case, your IP traffic would be routed via GNUnet
to a peer that has access to the Internet with the desired IP version.

Setting up an entry node into the GNUnet VPN primarily requires you
to enable the "VPN/PT" option in "gnunet-setup". This will launch the
"gnunet-service-vpn", "gnunet-service-dns" and "gnunet-daemon-pt"
processes. The "gnunet-service-vpn" will create a virtual interface
which will be used as the target for your IP traffic that enters the
VPN. Additionally, a second virtual interface will be created by
the "gnunet-service-dns" for your DNS traffic. You will then need to
specify which traffic you want to tunnel over GNUnet. If your ISP only
provides you with IPv4 or IPv6-access, you may choose to tunnel the
other IP protocol over the GNUnet VPN. If you do not have an ISP
(and are connected to other GNUnet peers via WLAN), you can also
choose to tunnel all IP traffic over GNUnet. This might also provide
you with some anonymity. After you enable the respective options
and restart your peer, your Internet traffic should be tunneled
over the GNUnet VPN.

The GNUnet VPN uses DNS-ALG to hijack your IP traffic. Whenever an
application resolves a hostname (i.e. 'gnunet.org'), the
"gnunet-daemon-pt" will instruct the "gnunet-service-dns" to intercept
the request (possibly route it over GNUnet as well) and replace the
normal answer with an IP in the range of the VPN's interface.
"gnunet-daemon-pt" will then tell "gnunet-service-vpn" to forward all
traffic it receives on the TUN interface via the VPN to the original
destination.

For applications that do not use DNS, you can also manually create
such a mapping using the gnunet-vpn command-line tool. Here, you
specfiy the desired address family of the result (i.e. "-4"), and the
intended target IP on the Internet ("-i 131.159.74.67") and
"gnunet-vpn" will tell you which IP address in the range of your
VPN tunnel was mapped.

@command{gnunet-vpn} can also be used to access "internal" services
offered by GNUnet nodes. So if you happen to know a peer and a
service offered by that peer, you can create an IP tunnel to
that peer by specifying the peer's identity, service name and
protocol (--tcp or --udp) and you will again receive an IP address
that will terminate at the respective peer's service.



@c NOTE: Inserted from Installation Handbook in original ``order'':
@c FIXME: Move this to User Handbook.
@node The graphical configuration interface
@section The graphical configuration interface

If you also would like to use @command{gnunet-gtk} and
@command{gnunet-setup} (highly recommended for beginners), do:

@menu
* Configuring your peer::
* Configuring the Friend-to-Friend (F2F) mode::
* Configuring the hostlist to bootstrap::
* Configuration of the HOSTLIST proxy settings::
* Configuring your peer to provide a hostlist ::
* Configuring the datastore::
* Configuring the MySQL database::
* Reasons for using MySQL::
* Reasons for not using MySQL::
* Setup Instructions::
* Testing::
* Performance Tuning::
* Setup for running Testcases::
* Configuring the Postgres database::
* Reasons to use Postgres::
* Reasons not to use Postgres::
* Manual setup instructions::
* Testing the setup manually::
* Configuring the datacache::
* Configuring the file-sharing service::
* Configuring logging::
* Configuring the transport service and plugins::
* Configuring the wlan transport plugin::
* Configuring HTTP(S) reverse proxy functionality using Apache or nginx::
* Blacklisting peers::
* Configuration of the HTTP and HTTPS transport plugins::
* Configuring the GNU Name System::
* Configuring the GNUnet VPN::
* Bandwidth Configuration::
* Configuring NAT::
* Peer configuration for distributions::
@end menu

@node Configuring your peer
@subsection Configuring your peer

This chapter will describe the various configuration options in GNUnet.

The easiest way to configure your peer is to use the
@command{gnunet-setup} tool.
@command{gnunet-setup} is part of the @command{gnunet-gtk}
application. You might have to install it separately.

Many of the specific sections from this chapter actually are linked from
within @command{gnunet-setup} to help you while using the setup tool.

While you can also configure your peer by editing the configuration
file by hand, this is not recommended for anyone except for developers
as it requires a more in-depth understanding of the configuration files
and internal dependencies of GNUnet.

@node Configuring the Friend-to-Friend (F2F) mode
@subsection Configuring the Friend-to-Friend (F2F) mode

GNUnet knows three basic modes of operation:
@itemize @bullet
@item In standard "peer-to-peer" mode,
your peer will connect to any peer.
@item In the pure "friend-to-friend"
mode, your peer will ONLY connect to peers from a list of friends
specified in the configuration.
@item Finally, in mixed mode,
GNUnet will only connect to arbitrary peers if it
has at least a specified number of connections to friends.
@end itemize

When configuring any of the F2F ("friend-to-friend") modes,
you first need to create a file with the peer identities
of your friends. Ask your friends to run

@example
$ gnunet-peerinfo -sq
@end example

@noindent
The resulting output of this command needs to be added to your
@file{friends} file, which is simply a plain text file with one line
per friend with the output from the above command.

You then specify the location of your @file{friends} file in the
@code{FRIENDS} option of the "topology" section.

Once you have created the @file{friends} file, you can tell GNUnet to only
connect to your friends by setting the @code{FRIENDS-ONLY} option
(again in the "topology" section) to YES.

If you want to run in mixed-mode, set "FRIENDS-ONLY" to NO and configure a
minimum number of friends to have (before connecting to arbitrary peers)
under the "MINIMUM-FRIENDS" option.

If you want to operate in normal P2P-only mode, simply set
@code{MINIMUM-FRIENDS} to zero and @code{FRIENDS_ONLY} to NO.
This is the default.

@node Configuring the hostlist to bootstrap
@subsection Configuring the hostlist to bootstrap

After installing the software you need to get connected to the GNUnet
network. The configuration file included in your download is already
configured to connect you to the GNUnet network.
In this section the relevant configuration settings are explained.

To get an initial connection to the GNUnet network and to get to know
peers already connected to the network you can use the so called
"bootstrap servers".
These servers can give you a list of peers connected to the network.
To use these bootstrap servers you have to configure the hostlist daemon
to activate bootstrapping.

To activate bootstrapping, edit the @code{[hostlist]}-section in your
configuration file. You have to set the argument @command{-b} in the
options line:

@example
[hostlist]
OPTIONS = -b
@end example

Additionally you have to specify which server you want to use.
The default bootstrapping server is
"@uref{http://v10.gnunet.org/hostlist, http://v10.gnunet.org/hostlist}".
[^] To set the server you have to edit the line "SERVERS" in the hostlist
section. To use the default server you should set the lines to

@example
SERVERS = http://v10.gnunet.org/hostlist [^]
@end example

@noindent
To use bootstrapping your configuration file should include these lines:

@example
[hostlist]
OPTIONS = -b
SERVERS = http://v10.gnunet.org/hostlist [^]
@end example

@noindent
Besides using bootstrap servers you can configure your GNUnet peer to
recieve hostlist advertisements.
Peers offering hostlists to other peers can send advertisement messages
to peers that connect to them. If you configure your peer to receive these
messages, your peer can download these lists and connect to the peers
included. These lists are persistent, which means that they are saved to
your hard disk regularly and are loaded during startup.

To activate hostlist learning you have to add the @command{-e}
switch to the @code{OPTIONS} line in the hostlist section:

@example
[hostlist]
OPTIONS = -b -e
@end example

@noindent
Furthermore you can specify in which file the lists are saved.
To save the lists in the file @file{hostlists.file} just add the line:

@example
HOSTLISTFILE = hostlists.file
@end example

@noindent
Best practice is to activate both bootstrapping and hostlist learning.
So your configuration file should include these lines:

@example
[hostlist]
OPTIONS = -b -e
HTTPPORT = 8080
SERVERS = http://v10.gnunet.org/hostlist [^]
HOSTLISTFILE = $SERVICEHOME/hostlists.file
@end example

@node Configuration of the HOSTLIST proxy settings
@subsection Configuration of the HOSTLIST proxy settings

The hostlist client can be configured to use a proxy to connect to the
hostlist server.
This functionality can be configured in the configuration file directly
or using the @command{gnunet-setup} tool.

The hostlist client supports the following proxy types at the moment:

@itemize @bullet
@item HTTP and HTTP 1.0 only proxy
@item SOCKS 4/4a/5/5 with hostname
@end itemize

In addition authentication at the proxy with username and password can be
configured.

To configure proxy support for the hostlist client in the
@command{gnunet-setup} tool, select the "hostlist" tab and select
the appropriate proxy type.
The hostname or IP address (including port if required) has to be entered
in the "Proxy hostname" textbox. If required, enter username and password
in the "Proxy username" and "Proxy password" boxes.
Be aware that this information will be stored in the configuration in
plain text (TODO: Add explanation and generalize the part in Chapter 3.6
about the encrypted home).

To provide these options directly in the configuration, you can
enter the following settings in the @code{[hostlist]} section of
the configuration:

@example
# Type of proxy server,
# Valid values: HTTP, HTTP_1_0, SOCKS4, SOCKS5, SOCKS4A, SOCKS5_HOSTNAME
# Default: HTTP
# PROXY_TYPE = HTTP

# Hostname or IP of proxy server
# PROXY =
# User name for proxy server
# PROXY_USERNAME =
# User password for proxy server
# PROXY_PASSWORD =
@end example

@node Configuring your peer to provide a hostlist
@subsection Configuring your peer to provide a hostlist

If you operate a peer permanently connected to GNUnet you can configure
your peer to act as a hostlist server, providing other peers the list of
peers known to him.

Your server can act as a bootstrap server and peers needing to obtain a
list of peers can contact it to download this list.
To download this hostlist the peer uses HTTP.
For this reason you have to build your peer with libgnurl (or libcurl)
and microhttpd support.

To configure your peer to act as a bootstrap server you have to add the
@command{-p} option to @code{OPTIONS} in the @code{[hostlist]} section
of your configuration file.
Besides that you have to specify a port number for the http server.
In conclusion you have to add the following lines:

@example
[hostlist]
HTTPPORT = 12980
OPTIONS = -p
@end example

@noindent
If your peer acts as a bootstrap server other peers should know about
that. You can advertise the hostlist your are providing to other peers.
Peers connecting to your peer will get a message containing an
advertisement for your hostlist and the URL where it can be downloaded.
If this peer is in learning mode, it will test the hostlist and, in the
case it can obtain the list successfully, it will save it for
bootstrapping.

To activate hostlist advertisement on your peer, you have to set the
following lines in your configuration file:

@example
[hostlist]
EXTERNAL_DNS_NAME = example.org
HTTPPORT = 12981
OPTIONS = -p -a
@end example

@noindent
With this configuration your peer will a act as a bootstrap server and
advertise this hostlist to other peers connecting to it.
The URL used to download the list will be
@code{@uref{http://example.org:12981/, http://example.org:12981/}}.

Please notice:

@itemize @bullet
@item The hostlist is @b{not} human readable, so you should not try to
download it using your webbrowser. Just point your GNUnet peer to the
address!
@item Advertising without providing a hostlist does not make sense and
will not work.
@end itemize

@node Configuring the datastore
@subsection Configuring the datastore

The datastore is what GNUnet uses for long-term storage of file-sharing
data. Note that long-term does not mean 'forever' since content does have
an expiration date, and of course storage space is finite (and hence
sometimes content may have to be discarded).

Use the @code{QUOTA} option to specify how many bytes of storage space
you are willing to dedicate to GNUnet.

In addition to specifying the maximum space GNUnet is allowed to use for
the datastore, you need to specify which database GNUnet should use to do
so. Currently, you have the choice between sqLite, MySQL and Postgres.

@node Configuring the MySQL database
@subsection Configuring the MySQL database

This section describes how to setup the MySQL database for GNUnet.

Note that the mysql plugin does NOT work with mysql before 4.1 since we
need prepared statements.
We are generally testing the code against MySQL 5.1 at this point.

@node Reasons for using MySQL
@subsection Reasons for using MySQL

@itemize @bullet

@item On up-to-date hardware wher
mysql can be used comfortably, this module
will have better performance than the other database choices (according
to our tests).

@item Its often possible to recover the mysql database from internal
inconsistencies. Some of the other databases do not support repair.
@end itemize

@node Reasons for not using MySQL
@subsection Reasons for not using MySQL

@itemize @bullet
@item Memory usage (likely not an issue if you have more than 1 GB)
@item Complex manual setup
@end itemize

@node Setup Instructions
@subsection Setup Instructions

@itemize @bullet

@item In @file{gnunet.conf} set in section @code{DATASTORE} the value for
@code{DATABASE} to @code{mysql}.

@item Access mysql as root:

@example
$ mysql -u root -p
@end example

@noindent
and issue the following commands, replacing $USER with the username
that will be running @command{gnunet-arm} (so typically "gnunet"):

@example
CREATE DATABASE gnunet;
GRANT select,insert,update,delete,create,alter,drop,create \
temporary tables ON gnunet.* TO $USER@@localhost;
SET PASSWORD FOR $USER@@localhost=PASSWORD('$the_password_you_like');
FLUSH PRIVILEGES;
@end example

@item
In the $HOME directory of $USER, create a @file{.my.cnf} file with the
following lines

@example
[client]
user=$USER
password=$the_password_you_like
@end example

@end itemize

Thats it. Note that @file{.my.cnf} file is a slight security risk unless
its on a safe partition. The @file{$HOME/.my.cnf} can of course be
a symbolic link.
Luckily $USER has only priviledges to mess up GNUnet's tables,
which should be pretty harmless.

@node Testing
@subsection Testing

You should briefly try if the database connection works. First, login
as $USER. Then use:

@example
$ mysql -u $USER
mysql> use gnunet;
@end example

@noindent
If you get the message

@example
Database changed
@end example

@noindent
it probably works.

If you get

@example
ERROR 2002: Can't connect to local MySQL server
through socket '/tmp/mysql.sock' (2)
@end example

@noindent
it may be resolvable by

@example
ln -s /var/run/mysqld/mysqld.sock /tmp/mysql.sock
@end example

@noindent
so there may be some additional trouble depending on your mysql setup.

@node Performance Tuning
@subsection Performance Tuning

For GNUnet, you probably want to set the option

@example
innodb_flush_log_at_trx_commit = 0
@end example

@noindent
for a rather dramatic boost in MySQL performance. However, this reduces
the "safety" of your database as with this options you may loose
transactions during a power outage.
While this is totally harmless for GNUnet, the option applies to all
applications using MySQL. So you should set it if (and only if) GNUnet is
the only application on your system using MySQL.

@node Setup for running Testcases
@subsection Setup for running Testcases

If you want to run the testcases, you must create a second database
"gnunetcheck" with the same username and password. This database will
then be used for testing (@command{make check}).

@node Configuring the Postgres database
@subsection Configuring the Postgres database

This text describes how to setup the Postgres database for GNUnet.

This Postgres plugin was developed for Postgres 8.3 but might work for
earlier versions as well.

@node Reasons to use Postgres
@subsection Reasons to use Postgres

@itemize @bullet
@item Easier to setup than MySQL
@item Real database
@end itemize

@node Reasons not to use Postgres
@subsection Reasons not to use Postgres

@itemize @bullet
@item Quite slow
@item Still some manual setup required
@end itemize

@node Manual setup instructions
@subsection Manual setup instructions

@itemize @bullet
@item In @file{gnunet.conf} set in section @code{DATASTORE} the value for
@code{DATABASE} to @code{postgres}.
@item Access Postgres to create a user:

@table @asis
@item with Postgres 8.x, use:

@example
# su - postgres
$ createuser
@end example

@noindent
and enter the name of the user running GNUnet for the role interactively.
Then, when prompted, do not set it to superuser, allow the creation of
databases, and do not allow the creation of new roles.

@item with Postgres 9.x, use:

@example
# su - postgres
$ createuser -d $GNUNET_USER
@end example

@noindent
where $GNUNET_USER is the name of the user running GNUnet.

@end table


@item
As that user (so typically as user "gnunet"), create a database (or two):

@example
$ createdb gnunet
# this way you can run "make check"
$ createdb gnunetcheck
@end example

@end itemize

Now you should be able to start @code{gnunet-arm}.

@node Testing the setup manually
@subsection Testing the setup manually

You may want to try if the database connection works. First, again login
as the user who will run @command{gnunet-arm}. Then use:

@example
$ psql gnunet # or gnunetcheck
gnunet=> \dt
@end example

@noindent
If, after you have started @command{gnunet-arm} at least once, you get
a @code{gn090} table here, it probably works.

@node Configuring the datacache
@subsection Configuring the datacache
@c %**end of header

The datacache is what GNUnet uses for storing temporary data. This data is
expected to be wiped completely each time GNUnet is restarted (or the
system is rebooted).

You need to specify how many bytes GNUnet is allowed to use for the
datacache using the @code{QUOTA} option in the section @code{[dhtcache]}.
Furthermore, you need to specify which database backend should be used to
store the data. Currently, you have the choice between
sqLite, MySQL and Postgres.

@node Configuring the file-sharing service
@subsection Configuring the file-sharing service

In order to use GNUnet for file-sharing, you first need to make sure
that the file-sharing service is loaded.
This is done by setting the @code{START_ON_DEMAND} option in
section @code{[fs]} to "YES". Alternatively, you can run

@example
$ gnunet-arm -i fs
@end example

@noindent
to start the file-sharing service by hand.

Except for configuring the database and the datacache the only important
option for file-sharing is content migration.

Content migration allows your peer to cache content from other peers as
well as send out content stored on your system without explicit requests.
This content replication has positive and negative impacts on both system
performance and privacy.

FIXME: discuss the trade-offs. Here is some older text about it...

Setting this option to YES allows gnunetd to migrate data to the local
machine. Setting this option to YES is highly recommended for efficiency.
Its also the default. If you set this value to YES, GNUnet will store
content on your machine that you cannot decrypt.
While this may protect you from liability if the judge is sane, it may
not (IANAL). If you put illegal content on your machine yourself, setting
this option to YES will probably increase your chances to get away with it
since you can plausibly deny that you inserted the content.
Note that in either case, your anonymity would have to be broken first
(which may be possible depending on the size of the GNUnet network and the
strength of the adversary).

@node Configuring logging
@subsection Configuring logging

Logging in GNUnet 0.9.0 is controlled via the "-L" and "-l" options.
Using @code{-L}, a log level can be specified. With log level
@code{ERROR} only serious errors are logged.
The default log level is @code{WARNING} which causes anything of
concern to be logged.
Log level @code{INFO} can be used to log anything that might be
interesting information whereas
@code{DEBUG} can be used by developers to log debugging messages
(but you need to run @code{./configure} with
@code{--enable-logging=verbose} to get them compiled).
The @code{-l} option is used to specify the log file.

Since most GNUnet services are managed by @code{gnunet-arm}, using the
@code{-l} or @code{-L} options directly is not possible.
Instead, they can be specified using the @code{OPTIONS} configuration
value in the respective section for the respective service.
In order to enable logging globally without editing the @code{OPTIONS}
values for each service, @command{gnunet-arm} supports a
@code{GLOBAL_POSTFIX} option.
The value specified here is given as an extra option to all services for
which the configuration does contain a service-specific @code{OPTIONS}
field.

@code{GLOBAL_POSTFIX} can contain the special sequence "@{@}" which
is replaced by the name of the service that is being started.
Furthermore, @code{GLOBAL_POSTFIX} is special in that sequences
starting with "$" anywhere in the string are expanded (according
to options in @code{PATHS}); this expansion otherwise is
only happening for filenames and then the "$" must be the
first character in the option. Both of these restrictions do
not apply to @code{GLOBAL_POSTFIX}.
Note that specifying @code{%} anywhere in the @code{GLOBAL_POSTFIX}
disables both of these features.

In summary, in order to get all services to log at level
@code{INFO} to log-files called @code{SERVICENAME-logs}, the
following global prefix should be used:

@example
GLOBAL_POSTFIX = -l $SERVICEHOME/@{@}-logs -L INFO
@end example

@node Configuring the transport service and plugins
@subsection Configuring the transport service and plugins

The transport service in GNUnet is responsible to maintain basic
connectivity to other peers.
Besides initiating and keeping connections alive it is also responsible
for address validation.

The GNUnet transport supports more than one transport protocol.
These protocols are configured together with the transport service.

The configuration section for the transport service itself is quite
similar to all the other services

@example
START_ON_DEMAND = YES
@@UNIXONLY@@ PORT = 2091
HOSTNAME = localhost
HOME = $SERVICEHOME
CONFIG = $DEFAULTCONFIG
BINARY = gnunet-service-transport
#PREFIX = valgrind
NEIGHBOUR_LIMIT = 50
ACCEPT_FROM = 127.0.0.1;
ACCEPT_FROM6 = ::1;
PLUGINS = tcp udp
UNIXPATH = /tmp/gnunet-service-transport.sock
@end example

Different are the settings for the plugins to load @code{PLUGINS}.
The first setting specifies which transport plugins to load.

@itemize @bullet
@item transport-unix
A plugin for local only communication with UNIX domain sockets. Used for
testing and available on unix systems only. Just set the port

@example
[transport-unix]
PORT = 22086
TESTING_IGNORE_KEYS = ACCEPT_FROM;
@end example

@item transport-tcp
A plugin for communication with TCP. Set port to 0 for client mode with
outbound only connections

@example
[transport-tcp]
# Use 0 to ONLY advertise as a peer behind NAT (no port binding)
PORT = 2086
ADVERTISED_PORT = 2086
TESTING_IGNORE_KEYS = ACCEPT_FROM;
# Maximum number of open TCP connections allowed
MAX_CONNECTIONS = 128
@end example

@item transport-udp
A plugin for communication with UDP. Supports peer discovery using
broadcasts.

@example
[transport-udp]
PORT = 2086
BROADCAST = YES
BROADCAST_INTERVAL = 30 s
MAX_BPS = 1000000
TESTING_IGNORE_KEYS = ACCEPT_FROM;
@end example

@item transport-http
HTTP and HTTPS support is split in two part: a client plugin initiating
outbound connections and a server part accepting connections from the
client. The client plugin just takes the maximum number of connections as
an argument.

@example
[transport-http_client]
MAX_CONNECTIONS = 128
TESTING_IGNORE_KEYS = ACCEPT_FROM;
@end example

@example
[transport-https_client]
MAX_CONNECTIONS = 128
TESTING_IGNORE_KEYS = ACCEPT_FROM;
@end example

@noindent
The server has a port configured and the maximum nunber of connections.
The HTTPS part has two files with the certificate key and the certificate
file.

The server plugin supports reverse proxies, so a external hostname can be
set using the @code{EXTERNAL_HOSTNAME} setting.
The webserver under this address should forward the request to the peer
and the configure port.

@example
[transport-http_server]
EXTERNAL_HOSTNAME = fulcrum.net.in.tum.de/gnunet
PORT = 1080
MAX_CONNECTIONS = 128
TESTING_IGNORE_KEYS = ACCEPT_FROM;
@end example

@example
[transport-https_server]
PORT = 4433
CRYPTO_INIT = NORMAL
KEY_FILE = https.key
CERT_FILE = https.cert
MAX_CONNECTIONS = 128
TESTING_IGNORE_KEYS = ACCEPT_FROM;
@end example

@item transport-wlan

The next section describes how to setup the WLAN plugin,
so here only the settings. Just specify the interface to use:

@example
[transport-wlan]
# Name of the interface in monitor mode (typically monX)
INTERFACE = mon0
# Real hardware, no testing
TESTMODE = 0
TESTING_IGNORE_KEYS = ACCEPT_FROM;
@end example
@end itemize

@node Configuring the wlan transport plugin
@subsection Configuring the wlan transport plugin

The wlan transport plugin enables GNUnet to send and to receive data on a
wlan interface.
It has not to be connected to a wlan network as long as sender and
receiver are on the same channel. This enables you to get connection to
GNUnet where no internet access is possible, for example during
catastrophes or when censorship cuts you off from the internet.


@menu
* Requirements for the WLAN plugin::
* Configuration::
* Before starting GNUnet::
* Limitations and known bugs::
@end menu


@node Requirements for the WLAN plugin
@subsubsection Requirements for the WLAN plugin

@itemize @bullet

@item wlan network card with monitor support and packet injection
(see @uref{http://www.aircrack-ng.org/, aircrack-ng.org})

@item Linux kernel with mac80211 stack, introduced in 2.6.22, tested with
2.6.35 and 2.6.38

@item Wlantools to create the a monitor interface, tested with airmon-ng
of the aircrack-ng package
@end itemize

@node Configuration
@subsubsection Configuration

There are the following options for the wlan plugin (they should be like
this in your default config file, you only need to adjust them if the
values are incorrect for your system)

@example
# section for the wlan transport plugin
[transport-wlan]
# interface to use, more information in the
# "Before starting GNUnet" section of the handbook.
INTERFACE = mon0
# testmode for developers:
# 0 use wlan interface,
#1 or 2 use loopback driver for tests 1 = server, 2 = client
TESTMODE = 0
@end example

@node Before starting GNUnet
@subsubsection Before starting GNUnet

Before starting GNUnet, you have to make sure that your wlan interface is
in monitor mode.
One way to put the wlan interface into monitor mode (if your interface
name is wlan0) is by executing:

@example
sudo airmon-ng start wlan0
@end example

@noindent
Here is an example what the result should look like:

@example
Interface Chipset Driver
wlan0 Intel 4965 a/b/g/n iwl4965 - [phy0]
(monitor mode enabled on mon0)
@end example

@noindent
The monitor interface is mon0 is the one that you have to put into the
configuration file.

@node Limitations and known bugs
@subsubsection Limitations and known bugs

Wlan speed is at the maximum of 1 Mbit/s because support for choosing the
wlan speed with packet injection was removed in newer kernels.
Please pester the kernel developers about fixing this.

The interface channel depends on the wlan network that the card is
connected to. If no connection has been made since the start of the
computer, it is usually the first channel of the card.
Peers will only find each other and communicate if they are on the same
channel. Channels must be set manually, i.e. using:

@example
iwconfig wlan0 channel 1
@end example

@node Configuring HTTP(S) reverse proxy functionality using Apache or nginx
@subsection Configuring HTTP(S) reverse proxy functionality using Apache or nginx

The HTTP plugin supports data transfer using reverse proxies. A reverse
proxy forwards the HTTP request he receives with a certain URL to another
webserver, here a GNUnet peer.

So if you have a running Apache or nginx webserver you can configure it to
be a GNUnet reverse proxy. Especially if you have a well-known webiste
this improves censorship resistance since it looks as normal surfing
behaviour.

To do so, you have to do two things:

@itemize @bullet
@item Configure your webserver to forward the GNUnet HTTP traffic
@item Configure your GNUnet peer to announce the respective address
@end itemize

As an example we want to use GNUnet peer running:

@itemize @bullet

@item HTTP server plugin on @code{gnunet.foo.org:1080}

@item HTTPS server plugin on @code{gnunet.foo.org:4433}

@item A apache or nginx webserver on
@uref{http://www.foo.org/, http://www.foo.org:80/}

@item A apache or nginx webserver on https://www.foo.org:443/
@end itemize

And we want the webserver to accept GNUnet traffic under
@code{http://www.foo.org/bar/}. The required steps are described here:

@menu
* Reverse Proxy - Configure your Apache2 HTTP webserver::
* Reverse Proxy - Configure your Apache2 HTTPS webserver::
* Reverse Proxy - Configure your nginx HTTPS webserver::
* Reverse Proxy - Configure your nginx HTTP webserver::
* Reverse Proxy - Configure your GNUnet peer::
@end menu

@node Reverse Proxy - Configure your Apache2 HTTP webserver
@subsubsection Reverse Proxy - Configure your Apache2 HTTP webserver

First of all you need mod_proxy installed.

Edit your webserver configuration. Edit
@code{/etc/apache2/apache2.conf} or the site-specific configuration file.

In the respective @code{server config},@code{virtual host} or
@code{directory} section add the following lines:

@example
ProxyTimeout 300
ProxyRequests Off
<Location /bar/ >
ProxyPass http://gnunet.foo.org:1080/
ProxyPassReverse http://gnunet.foo.org:1080/
</Location>
@end example

@node Reverse Proxy - Configure your Apache2 HTTPS webserver
@subsubsection Reverse Proxy - Configure your Apache2 HTTPS webserver

We assume that you already have an HTTPS server running, if not please
check how to configure a HTTPS host. An uncomplicated to use example
is the example configuration file for Apache2/HTTPD provided in
@file{apache2/sites-available/default-ssl}.

In the respective HTTPS @code{server config},@code{virtual host} or
@code{directory} section add the following lines:

@example
SSLProxyEngine On
ProxyTimeout 300
ProxyRequests Off
<Location /bar/ >
ProxyPass https://gnunet.foo.org:4433/
ProxyPassReverse https://gnunet.foo.org:4433/
</Location>
@end example

@noindent
More information about the apache mod_proxy configuration can be found
in the Apache documentation@footnote{@uref{http://httpd.apache.org/docs/2.2/mod/mod_proxy.html#proxypass, http://httpd.apache.org/docs/2.2/mod/mod_proxy.html#proxypass}}

@node Reverse Proxy - Configure your nginx HTTPS webserver
@subsubsection Reverse Proxy - Configure your nginx HTTPS webserver

Since nginx does not support chunked encoding, you first of all have to
install the @code{chunkin} module@footnote{@uref{http://wiki.nginx.org/HttpChunkinModule, http://wiki.nginx.org/HttpChunkinModule}}

To enable chunkin add:

@example
chunkin on;
error_page 411 = @@my_411_error;
location @@my_411_error @{
chunkin_resume;
@}
@end example

@noindent
Edit your webserver configuration. Edit @file{/etc/nginx/nginx.conf} or
the site-specific configuration file.

In the @code{server} section add:

@example
location /bar/ @{
proxy_pass http://gnunet.foo.org:1080/;
proxy_buffering off;
proxy_connect_timeout 5; # more than http_server
proxy_read_timeout 350; # 60 default, 300s is GNUnet's idle timeout
proxy_http_version 1.1; # 1.0 default
proxy_next_upstream error timeout invalid_header http_500 http_503 http_502 http_504;
@}
@end example

@node Reverse Proxy - Configure your nginx HTTP webserver
@subsubsection Reverse Proxy - Configure your nginx HTTP webserver

Edit your webserver configuration. Edit @file{/etc/nginx/nginx.conf} or
the site-specific configuration file.

In the @code{server} section add:

@example
ssl_session_timeout 6m;
location /bar/
@{
proxy_pass https://gnunet.foo.org:4433/;
proxy_buffering off;
proxy_connect_timeout 5; # more than http_server
proxy_read_timeout 350; # 60 default, 300s is GNUnet's idle timeout
proxy_http_version 1.1; # 1.0 default
proxy_next_upstream error timeout invalid_header http_500 http_503 http_502 http_504;
@}
@end example

@node Reverse Proxy - Configure your GNUnet peer
@subsubsection Reverse Proxy - Configure your GNUnet peer

To have your GNUnet peer announce the address, you have to specify the
@code{EXTERNAL_HOSTNAME} option in the @code{[transport-http_server]}
section:

@example
[transport-http_server]
EXTERNAL_HOSTNAME = http://www.foo.org/bar/
@end example

@noindent
and/or @code{[transport-https_server]} section:

@example
[transport-https_server]
EXTERNAL_HOSTNAME = https://www.foo.org/bar/
@end example

@noindent
Now restart your webserver and your peer...

@node Blacklisting peers
@subsection Blacklisting peers

Transport service supports to deny connecting to a specific peer of to a
specific peer with a specific transport plugin using te blacklisting
component of transport service. With@ blacklisting it is possible to deny
connections to specific peers of@ to use a specific plugin to a specific
peer. Peers can be blacklisted using@ the configuration or a blacklist
client can be asked.

To blacklist peers using the configuration you have to add a section to
your configuration containing the peer id of the peer to blacklist and
the plugin@ if required.

Examples:

To blacklist connections to P565... on peer AG2P... using tcp add:

@c FIXME: This is too long and produces errors in the pdf.
@example
[transport-blacklist AG2PHES1BARB9IJCPAMJTFPVJ5V3A72S3F2A8SBUB8DAQ2V0O3V8G6G2JU56FHGFOHMQVKBSQFV98TCGTC3RJ1NINP82G0RC00N1520]
P565723JO1C2HSN6J29TAQ22MN6CI8HTMUU55T0FUQG4CMDGGEQ8UCNBKUMB94GC8R9G4FB2SF9LDOBAJ6AMINBP4JHHDD6L7VD801G = tcp
@end example

To blacklist connections to P565... on peer AG2P... using all plugins add:

@example
[transport-blacklist-AG2PHES1BARB9IJCPAMJTFPVJ5V3A72S3F2A8SBUB8DAQ2V0O3V8G6G2JU56FHGFOHMQVKBSQFV98TCGTC3RJ1NINP82G0RC00N1520]
P565723JO1C2HSN6J29TAQ22MN6CI8HTMUU55T0FUQG4CMDGGEQ8UCNBKUMB94GC8R9G4FB2SF9LDOBAJ6AMINBP4JHHDD6L7VD801G =
@end example

You can also add a blacklist client usign the blacklist API. On a
blacklist check, blacklisting first checks internally if the peer is
blacklisted and if not, it asks the blacklisting clients. Clients are
asked if it is OK to connect to a peer ID, the plugin is omitted.

On blacklist check for (peer, plugin)
@itemize @bullet
@item Do we have a local blacklist entry for this peer and this plugin?@
@item YES: disallow connection@
@item Do we have a local blacklist entry for this peer and all plugins?@
@item YES: disallow connection@
@item Does one of the clients disallow?@
@item YES: disallow connection
@end itemize

@node Configuration of the HTTP and HTTPS transport plugins
@subsection Configuration of the HTTP and HTTPS transport plugins

The client parts of the http and https transport plugins can be configured
to use a proxy to connect to the hostlist server. This functionality can
be configured in the configuration file directly or using the
gnunet-setup tool.

Both the HTTP and HTTPS clients support the following proxy types at
the moment:

@itemize @bullet
@item HTTP 1.1 proxy
@item SOCKS 4/4a/5/5 with hostname
@end itemize

In addition authentication at the proxy with username and password can be
configured.

To configure proxy support for the clients in the gnunet-setup tool,
select the "transport" tab and activate the respective plugin. Now you
can select the appropriate proxy type. The hostname or IP address
(including port if required) has to be entered in the "Proxy hostname"
textbox. If required, enter username and password in the "Proxy username"
and "Proxy password" boxes. Be aware that these information will be stored
in the configuration in plain text.

To configure these options directly in the configuration, you can
configure the following settings in the @code{[transport-http_client]}
and @code{[transport-https_client]} section of the configuration:

@example
# Type of proxy server,
# Valid values: HTTP, SOCKS4, SOCKS5, SOCKS4A, SOCKS5_HOSTNAME
# Default: HTTP
# PROXY_TYPE = HTTP

# Hostname or IP of proxy server
# PROXY =
# User name for proxy server
# PROXY_USERNAME =
# User password for proxy server
# PROXY_PASSWORD =
@end example

@node Configuring the GNU Name System
@subsection Configuring the GNU Name System

@menu
* Configuring system-wide DNS interception::
* Configuring the GNS nsswitch plugin::
* Configuring GNS on W32::
* GNS Proxy Setup::
* Setup of the GNS CA::
* Testing the GNS setup::
@end menu


@node Configuring system-wide DNS interception
@subsubsection Configuring system-wide DNS interception

Before you install GNUnet, make sure you have a user and group 'gnunet'
as well as an empty group 'gnunetdns'.

When using GNUnet with system-wide DNS interception, it is absolutely
necessary for all GNUnet service processes to be started by
@code{gnunet-service-arm} as user and group 'gnunet'. You also need to be
sure to run @code{make install} as root (or use the @code{sudo} option to
configure) to grant GNUnet sufficient privileges.

With this setup, all that is required for enabling system-wide DNS
interception is for some GNUnet component (VPN or GNS) to request it.
The @code{gnunet-service-dns} will then start helper programs that will
make the necessary changes to your firewall (@code{iptables}) rules.

Note that this will NOT work if your system sends out DNS traffic to a
link-local IPv6 address, as in this case GNUnet can intercept the traffic,
but not inject the responses from the link-local IPv6 address. Hence you
cannot use system-wide DNS interception in conjunction with link-local
IPv6-based DNS servers. If such a DNS server is used, it will bypass
GNUnet's DNS traffic interception.

Using the GNU Name System (GNS) requires two different configuration
steps.
First of all, GNS needs to be integrated with the operating system. Most
of this section is about the operating system level integration.

The remainder of this chapter will detail the various methods for
configuring the use of GNS with your operating system.

At this point in time you have different options depending on your OS:

@table @asis

@item Use the gnunet-gns-proxy This approach works for all operating
systems and is likely the easiest. However, it enables GNS only for
browsers, not for other applications that might be using DNS, such as SSH.
Still, using the proxy is required for using HTTP with GNS and is thus
recommended for all users. To do this, you simply have to run the
@code{gnunet-gns-proxy-setup-ca} script as the user who will run the
browser (this will create a GNS certificate authority (CA) on your system
and import its key into your browser), then start @code{gnunet-gns-proxy}
and inform your browser to use the Socks5 proxy which
@code{gnunet-gns-proxy} makes available by default on port 7777.
@item Use a nsswitch plugin (recommended on GNU systems)
This approach has the advantage of offering fully personalized resolution
even on multi-user systems. A potential disadvantage is that some
applications might be able to bypass GNS.
@item Use a W32 resolver plugin (recommended on W32)
This is currently the only option on W32 systems.
@item Use system-wide DNS packet interception
This approach is recommended for the GNUnet VPN. It can be used to handle
GNS at the same time; however, if you only use this method, you will only
get one root zone per machine (not so great for multi-user systems).
@end table

You can combine system-wide DNS packet interception with the nsswitch
plugin.
The setup of the system-wide DNS interception is described here. All of
the other GNS-specific configuration steps are described in the following
sections.

@node Configuring the GNS nsswitch plugin
@subsubsection Configuring the GNS nsswitch plugin

The Name Service Switch (NSS) is a facility in Unix-like operating systems
@footnote{More accurate: NSS is a functionality of the GNU C Library}
that provides a variety of sources for common configuration databases and
name resolution mechanisms.
A superuser (system administrator) usually configures the
operating system's name services using the file
@file{/etc/nsswitch.conf}.

GNS provides a NSS plugin to integrate GNS name resolution with the
operating system's name resolution process.
To use the GNS NSS plugin you have to either

@itemize @bullet
@item install GNUnet as root or
@item compile GNUnet with the @code{--with-sudo=yes} switch.
@end itemize

Name resolution is controlled by the @emph{hosts} section in the NSS
configuration. By default this section first performs a lookup in the
@file{/etc/hosts} file and then in DNS.
The nsswitch file should contain a line similar to:

@example
hosts: files dns [NOTFOUND=return] mdns4_minimal mdns4
@end example

@noindent
Here the GNS NSS plugin can be added to perform a GNS lookup before
performing a DNS lookup.
The GNS NSS plugin has to be added to the "hosts" section in
@file{/etc/nsswitch.conf} file before DNS related plugins:

@example
...
hosts: files gns [NOTFOUND=return] dns mdns4_minimal mdns4
...
@end example

@noindent
The @code{NOTFOUND=return} will ensure that if a @code{.gnu} name is not
found in GNS it will not be queried in DNS.

@node Configuring GNS on W32
@subsubsection Configuring GNS on W32

This document is a guide to configuring GNU Name System on W32-compatible
platforms.

After GNUnet is installed, run the w32nsp-install tool:

@example
w32nsp-install.exe libw32nsp-0.dll
@end example

@noindent
('0' is the library version of W32 NSP; it might increase in the future,
change the invocation accordingly).

This will install GNS namespace provider into the system and allow other
applications to resolve names that end in '@strong{gnu}'
and '@strong{zkey}'. Note that namespace provider requires
gnunet-gns-helper-service-w32 to be running, as well as gns service
itself (and its usual dependencies).

Namespace provider is hardcoded to connect to @strong{127.0.0.1:5353},
and this is where gnunet-gns-helper-service-w32 should be listening to
(and is configured to listen to by default).

To uninstall the provider, run:

@example
w32nsp-uninstall.exe
@end example

@noindent
(uses provider GUID to uninstall it, does not need a dll name).

Note that while MSDN claims that other applications will only be able to
use the new namespace provider after re-starting, in reality they might
stat to use it without that. Conversely, they might stop using the
provider after it's been uninstalled, even if they were not re-started.
W32 will not permit namespace provider library to be deleted or
overwritten while the provider is installed, and while there is at least
one process still using it (even after it was uninstalled).

@node GNS Proxy Setup
@subsubsection GNS Proxy Setup

When using the GNU Name System (GNS) to browse the WWW, there are several
issues that can be solved by adding the GNS Proxy to your setup:

@itemize @bullet

@item If the target website does not support GNS, it might assume that it
is operating under some name in the legacy DNS system (such as
example.com). It may then attempt to set cookies for that domain, and the
web server might expect a @code{Host: example.com} header in the request
from your browser.
However, your browser might be using @code{example.gnu} for the
@code{Host} header and might only accept (and send) cookies for
@code{example.gnu}. The GNS Proxy will perform the necessary translations
of the hostnames for cookies and HTTP headers (using the LEHO record for
the target domain as the desired substitute).

@item If using HTTPS, the target site might include an SSL certificate
which is either only valid for the LEHO domain or might match a TLSA
record in GNS. However, your browser would expect a valid certificate for
@code{example.gnu}, not for some legacy domain name. The proxy will
validate the certificate (either against LEHO or TLSA) and then
on-the-fly produce a valid certificate for the exchange, signed by your
own CA. Assuming you installed the CA of your proxy in your browser's
certificate authority list, your browser will then trust the
HTTPS/SSL/TLS connection, as the hostname mismatch is hidden by the proxy.

@item Finally, the proxy will in the future indicate to the server that it
speaks GNS, which will enable server operators to deliver GNS-enabled web
sites to your browser (and continue to deliver legacy links to legacy
browsers)
@end itemize

@node Setup of the GNS CA
@subsubsection Setup of the GNS CA

First you need to create a CA certificate that the proxy can use.
To do so use the provided script gnunet-gns-proxy-ca:

@example
$ gnunet-gns-proxy-setup-ca
@end example

@noindent
This will create a personal certification authority for you and add this
authority to the firefox and chrome database. The proxy will use the this
CA certificate to generate @code{*.gnu} client certificates on the fly.

Note that the proxy uses libcurl. Make sure your version of libcurl uses
GnuTLS and NOT OpenSSL. The proxy will @b{not} work with libcurl compiled
against OpenSSL.

You can check the configuration your libcurl was build with by
running:

@example
curl --version
@end example

the output will look like this (without the linebreaks):

@example
gnurl --version
curl 7.56.0 (x86_64-unknown-linux-gnu) libcurl/7.56.0 \
GnuTLS/3.5.13 zlib/1.2.11 libidn2/2.0.4
Release-Date: 2017-10-08
Protocols: http https
Features: AsynchDNS IDN IPv6 Largefile NTLM SSL libz \
TLS-SRP UnixSockets HTTPS-proxy
@end example

@node Testing the GNS setup
@subsubsection Testing the GNS setup

Now for testing purposes we can create some records in our zone to test
the SSL functionality of the proxy:

@example
$ gnunet-identity -C test
$ gnunet-namestore -a -e "1 d" -n "homepage" \
  -t A -V 131.159.74.67 -z test
$ gnunet-namestore -a -e "1 d" -n "homepage" \
  -t LEHO -V "gnunet.org" -z test
@end example

@noindent
At this point we can start the proxy. Simply execute

@example
$ gnunet-gns-proxy
@end example

@noindent
Configure your browser to use this SOCKSv5 proxy on port 7777 and visit
this link.
If you use @command{Firefox} (or one of its deriviates/forks such as
Icecat) you also have to go to @code{about:config} and set the key
@code{network.proxy.socks_remote_dns} to @code{true}.

When you visit @code{https://homepage.test/}, you should get to the
@code{https://gnunet.org/} frontpage and the browser (with the correctly
configured proxy) should give you a valid SSL certificate for
@code{homepage.gnu} and no warnings. It should look like this:

@c FIXME: Image does not exist, create it or save it from Drupal?
@c @image{images/gnunethpgns.png,5in,, picture of homepage.gnu in Webbrowser}


@node Configuring the GNUnet VPN
@subsection Configuring the GNUnet VPN

@menu
* IPv4 address for interface::
* IPv6 address for interface::
* Configuring the GNUnet VPN DNS::
* Configuring the GNUnet VPN Exit Service::
* IP Address of external DNS resolver::
* IPv4 address for Exit interface::
* IPv6 address for Exit interface::
@end menu

Before configuring the GNUnet VPN, please make sure that system-wide DNS
interception is configured properly as described in the section on the
GNUnet DNS setup. @pxref{Configuring the GNU Name System},
if you haven't done so already.

The default options for the GNUnet VPN are usually sufficient to use
GNUnet as a Layer 2 for your Internet connection.
However, what you always have to specify is which IP protocol you want
to tunnel: IPv4, IPv6 or both.
Furthermore, if you tunnel both, you most likely should also tunnel
all of your DNS requests.
You theoretically can tunnel "only" your DNS traffic, but that usually
makes little sense.

The other options as shown on the gnunet-setup tool are:

@node IPv4 address for interface
@subsubsection IPv4 address for interface

This is the IPv4 address the VPN interface will get. You should pick an
'private' IPv4 network that is not yet in use for you system. For example,
if you use @code{10.0.0.1/255.255.0.0} already, you might use
@code{10.1.0.1/255.255.0.0}.
If you use @code{10.0.0.1/255.0.0.0} already, then you might use
@code{192.168.0.1/255.255.0.0}.
If your system is not in a private IP-network, using any of the above will
work fine.
You should try to make the mask of the address big enough
(@code{255.255.0.0} or, even better, @code{255.0.0.0}) to allow more
mappings of remote IP Addresses into this range.
However, even a @code{255.255.255.0} mask will suffice for most users.

@node IPv6 address for interface
@subsubsection IPv6 address for interface

The IPv6 address the VPN interface will get. Here you can specify any
non-link-local address (the address should not begin with @code{fe80:}).
A subnet Unique Local Unicast (@code{fd00::/8} prefix) that you are
currently not using would be a good choice.

@node Configuring the GNUnet VPN DNS
@subsubsection Configuring the GNUnet VPN DNS

To resolve names for remote nodes, activate the DNS exit option.

@node Configuring the GNUnet VPN Exit Service
@subsubsection Configuring the GNUnet VPN Exit Service

If you want to allow other users to share your Internet connection (yes,
this may be dangerous, just as running a Tor exit node) or want to
provide access to services on your host (this should be less dangerous,
as long as those services are secure), you have to enable the GNUnet exit
daemon.

You then get to specify which exit functions you want to provide. By
enabling the exit daemon, you will always automatically provide exit
functions for manually configured local services (this component of the
system is under
development and not documented further at this time). As for those
services you explicitly specify the target IP address and port, there is
no significant security risk in doing so.

Furthermore, you can serve as a DNS, IPv4 or IPv6 exit to the Internet.
Being a DNS exit is usually pretty harmless. However, enabling IPv4 or
IPv6-exit without further precautions may enable adversaries to access
your local network, send spam, attack other systems from your Internet
connection and to other mischief that will appear to come from your
machine. This may or may not get you into legal trouble.
If you want to allow IPv4 or IPv6-exit functionality, you should strongly
consider adding additional firewall rules manually to protect your local
network and to restrict outgoing TCP traffic (i.e. by not allowing access
to port 25). While we plan to improve exit-filtering in the future,
you're currently on your own here.
Essentially, be prepared for any kind of IP-traffic to exit the respective
TUN interface (and GNUnet will enable IP-forwarding and NAT for the
interface automatically).

Additional configuration options of the exit as shown by the gnunet-setup
tool are:

@node IP Address of external DNS resolver
@subsubsection IP Address of external DNS resolver

If DNS traffic is to exit your machine, it will be send to this DNS
resolver. You can specify an IPv4 or IPv6 address.

@node IPv4 address for Exit interface
@subsubsection IPv4 address for Exit interface

This is the IPv4 address the Interface will get. Make the mask of the
address big enough (255.255.0.0 or, even better, 255.0.0.0) to allow more
mappings of IP addresses into this range. As for the VPN interface, any
unused, private IPv4 address range will do.

@node IPv6 address for Exit interface
@subsubsection IPv6 address for Exit interface

The public IPv6 address the interface will get. If your kernel is not a
very recent kernel and you are willing to manually enable IPv6-NAT, the
IPv6 address you specify here must be a globally routed IPv6 address of
your host.

Suppose your host has the address @code{2001:4ca0::1234/64}, then
using @code{2001:4ca0::1:0/112} would be fine (keep the first 64 bits,
then change at least one bit in the range before the bitmask, in the
example above we changed bit 111 from 0 to 1).

You may also have to configure your router to route traffic for the entire
subnet (@code{2001:4ca0::1:0/112} for example) through your computer (this
should be automatic with IPv6, but obviously anything can be
disabled).

@node Bandwidth Configuration
@subsection Bandwidth Configuration

You can specify how many bandwidth GNUnet is allowed to use to receive
and send data. This is important for users with limited bandwidth or
traffic volume.

@node Configuring NAT
@subsection Configuring NAT

Most hosts today do not have a normal global IP address but instead are
behind a router performing Network Address Translation (NAT) which assigns
each host in the local network a private IP address.
As a result, these machines cannot trivially receive inbound connections
from the Internet. GNUnet supports NAT traversal to enable these machines
to receive incoming connections from other peers despite their
limitations.

In an ideal world, you can press the "Attempt automatic configuration"
button in gnunet-setup to automatically configure your peer correctly.
Alternatively, your distribution might have already triggered this
automatic configuration during the installation process.
However, automatic configuration can fail to determine the optimal
settings, resulting in your peer either not receiving as many connections
as possible, or in the worst case it not connecting to the network at all.

To manually configure the peer, you need to know a few things about your
network setup. First, determine if you are behind a NAT in the first
place.
This is always the case if your IP address starts with "10.*" or
"192.168.*". Next, if you have control over your NAT router, you may
choose to manually configure it to allow GNUnet traffic to your host.
If you have configured your NAT to forward traffic on ports 2086 (and
possibly 1080) to your host, you can check the "NAT ports have been opened
manually" option, which corresponds to the "PUNCHED_NAT" option in the
configuration file. If you did not punch your NAT box, it may still be
configured to support UPnP, which allows GNUnet to automatically
configure it. In that case, you need to install the "upnpc" command,
enable UPnP (or PMP) on your NAT box and set the "Enable NAT traversal
via UPnP or PMP" option (corresponding to "ENABLE_UPNP" in the
configuration file).

Some NAT boxes can be traversed using the autonomous NAT traversal method.
This requires certain GNUnet components to be installed with "SUID"
prividledges on your system (so if you're installing on a system you do
not have administrative rights to, this will not work).
If you installed as 'root', you can enable autonomous NAT traversal by
checking the "Enable NAT traversal using ICMP method".
The ICMP method requires a way to determine your NAT's external (global)
IP address. This can be done using either UPnP, DynDNS, or by manual
configuration. If you have a DynDNS name or know your external IP address,
you should enter that name under "External (public) IPv4 address" (which
corresponds to the "EXTERNAL_ADDRESS" option in the configuration file).
If you leave the option empty, GNUnet will try to determine your external
IP address automatically (which may fail, in which case autonomous
NAT traversal will then not work).

Finally, if you yourself are not behind NAT but want to be able to
connect to NATed peers using autonomous NAT traversal, you need to check
the "Enable connecting to NATed peers using ICMP method" box.


@node Peer configuration for distributions
@subsection Peer configuration for distributions

The "GNUNET_DATA_HOME" in "[path]" in @file{/etc/gnunet.conf} should be
manually set to "/var/lib/gnunet/data/" as the default
"~/.local/share/gnunet/" is probably not that appropriate in this case.
Similarly, distributions may consider pointing "GNUNET_RUNTIME_DIR" to
"/var/run/gnunet/" and "GNUNET_HOME" to "/var/lib/gnunet/". Also, should a
distribution decide to override system defaults, all of these changes
should be done in a custom @file{/etc/gnunet.conf} and not in the files
in the @file{config.d/} directory.

Given the proposed access permissions, the "gnunet-setup" tool must be
run as use "gnunet" (and with option "-c /etc/gnunet.conf" so that it
modifies the system configuration). As always, gnunet-setup should be run
after the GNUnet peer was stopped using "gnunet-arm -e". Distributions
might want to include a wrapper for gnunet-setup that allows the
desktop-user to "sudo" (i.e. using gtksudo) to the "gnunet" user account
and then runs "gnunet-arm -e", "gnunet-setup" and "gnunet-arm -s" in
sequence.

@node How to start and stop a GNUnet peer
@section How to start and stop a GNUnet peer

This section describes how to start a GNUnet peer. It assumes that you
have already compiled and installed GNUnet and its' dependencies.
Before you start a GNUnet peer, you may want to create a configuration
file using gnunet-setup (but you do not have to).
Sane defaults should exist in your
@file{$GNUNET_PREFIX/share/gnunet/config.d/} directory, so in practice
you could simply start without any configuration. If you want to
configure your peer later, you need to stop it before invoking the
@code{gnunet-setup} tool to customize further and to test your
configuration (@code{gnunet-setup} has build-in test functions).

The most important option you might have to still set by hand is in
[PATHS]. Here, you use the option "GNUNET_HOME" to specify the path where
GNUnet should store its data.
It defaults to @code{$HOME/}, which again should work for most users.
Make sure that the directory specified as GNUNET_HOME is writable to
the user that you will use to run GNUnet (note that you can run frontends
using other users, GNUNET_HOME must only be accessible to the user used to
run the background processes).

You will also need to make one central decision: should all of GNUnet be
run under your normal UID, or do you want distinguish between system-wide
(user-independent) GNUnet services and personal GNUnet services. The
multi-user setup is slightly more complicated, but also more secure and
generally recommended.

@menu
* The Single-User Setup::
* The Multi-User Setup::
* Killing GNUnet services::
* Access Control for GNUnet::
@end menu

@node The Single-User Setup
@subsection The Single-User Setup

For the single-user setup, you do not need to do anything special and can
just start the GNUnet background processes using @code{gnunet-arm}.
By default, GNUnet looks in @file{~/.config/gnunet.conf} for a
configuration (or @code{$XDG_CONFIG_HOME/gnunet.conf} if@
@code{$XDG_CONFIG_HOME} is defined). If your configuration lives
elsewhere, you need to pass the @code{-c FILENAME} option to all GNUnet
commands.

Assuming the configuration file is called @file{~/.config/gnunet.conf},
you start your peer using the @code{gnunet-arm} command (say as user
@code{gnunet}) using:

@example
gnunet-arm -c ~/.config/gnunet.conf -s
@end example

@noindent
The "-s" option here is for "start". The command should return almost
instantly. If you want to stop GNUnet, you can use:

@example
gnunet-arm -c ~/.config/gnunet.conf -e
@end example

@noindent
The "-e" option here is for "end".

Note that this will only start the basic peer, no actual applications
will be available.
If you want to start the file-sharing service, use (after starting
GNUnet):

@example
gnunet-arm -c ~/.config/gnunet.conf -i fs
@end example

@noindent
The "-i fs" option here is for "initialize" the "fs" (file-sharing)
application. You can also selectively kill only file-sharing support using

@example
gnunet-arm -c ~/.config/gnunet.conf -k fs
@end example

@noindent
Assuming that you want certain services (like file-sharing) to be always
automatically started whenever you start GNUnet, you can activate them by
setting "IMMEDIATE_START=YES" in the respective section of the configuration
file (for example, "[fs]"). Then GNUnet with file-sharing support would
be started whenever you@ enter:

@example
gnunet-arm -c ~/.config/gnunet.conf -s
@end example

@noindent
Alternatively, you can combine the two options:

@example
gnunet-arm -c ~/.config/gnunet.conf -s -i fs
@end example

@noindent
Using @code{gnunet-arm} is also the preferred method for initializing
GNUnet from @code{init}.

Finally, you should edit your @code{crontab} (using the @code{crontab}
command) and insert a line@

@example
@@reboot gnunet-arm -c ~/.config/gnunet.conf -s
@end example

to automatically start your peer whenever your system boots.

@node The Multi-User Setup
@subsection The Multi-User Setup

This requires you to create a user @code{gnunet} and an additional group
@code{gnunetdns}, prior to running @code{make install} during
installation.
Then, you create a configuration file @file{/etc/gnunet.conf} which should
contain the lines:@

@example
[arm]
START_SYSTEM_SERVICES = YES
START_USER_SERVICES = NO
@end example

@noindent
Then, perform the same steps to run GNUnet as in the per-user
configuration, except as user @code{gnunet} (including the
@code{crontab} installation).
You may also want to run @code{gnunet-setup} to configure your peer
(databases, etc.).
Make sure to pass @code{-c /etc/gnunet.conf} to all commands. If you
run @code{gnunet-setup} as user @code{gnunet}, you might need to change
permissions on @file{/etc/gnunet.conf} so that the @code{gnunet} user can
write to the file (during setup).

Afterwards, you need to perform another setup step for each normal user
account from which you want to access GNUnet. First, grant the normal user
(@code{$USER}) permission to the group gnunet:

@example
# adduser $USER gnunet
@end example

@noindent
Then, create a configuration file in @file{~/.config/gnunet.conf} for the
$USER with the lines:

@example
[arm]
START_SYSTEM_SERVICES = NO
START_USER_SERVICES = YES
@end example

@noindent
This will ensure that @code{gnunet-arm} when started by the normal user
will only run services that are per-user, and otherwise rely on the
system-wide services.
Note that the normal user may run gnunet-setup, but the
configuration would be ineffective as the system-wide services will use
@file{/etc/gnunet.conf} and ignore options set by individual users.

Again, each user should then start the peer using
@file{gnunet-arm -s} --- and strongly consider adding logic to start
the peer automatically to their crontab.

Afterwards, you should see two (or more, if you have more than one USER)
@code{gnunet-service-arm} processes running in your system.

@node Killing GNUnet services
@subsection Killing GNUnet services

It is not necessary to stop GNUnet services explicitly when shutting
down your computer.

It should be noted that manually killing "most" of the
@code{gnunet-service} processes is generally not a successful method for
stopping a peer (since @code{gnunet-service-arm} will instantly restart
them). The best way to explicitly stop a peer is using
@code{gnunet-arm -e}; note that the per-user services may need to be
terminated before the system-wide services will terminate normally.

@node Access Control for GNUnet
@subsection Access Control for GNUnet

This chapter documents how we plan to make access control work within the
GNUnet system for a typical peer. It should be read as a best-practice
installation guide for advanced users and builders of binary
distributions. The recommendations in this guide apply to POSIX-systems
with full support for UNIX domain sockets only.

Note that this is an advanced topic. The discussion presumes a very good
understanding of users, groups and file permissions. Normal users on
hosts with just a single user can just install GNUnet under their own
account (and possibly allow the installer to use SUDO to grant additional
permissions for special GNUnet tools that need additional rights).
The discussion below largely applies to installations where multiple users
share a system and to installations where the best possible security is
paramount.

A typical GNUnet system consists of components that fall into four
categories:

@table @asis

@item User interfaces
User interfaces are not security sensitive and are supposed to be run and
used by normal system users.
The GTK GUIs and most command-line programs fall into this category.
Some command-line tools (like gnunet-transport) should be excluded as they
offer low-level access that normal users should not need.
@item System services and support tools
System services should always run and offer services that can then be
accessed by the normal users.
System services do not require special permissions, but as they are not
specific to a particular user, they probably should not run as a
particular user. Also, there should typically only be one GNUnet peer per
host. System services include the gnunet-service and gnunet-daemon
programs; support tools include command-line programs such as gnunet-arm.
@item Priviledged helpers
Some GNUnet components require root rights to open raw sockets or perform
other special operations. These gnunet-helper binaries are typically
installed SUID and run from services or daemons.
@item Critical services
Some GNUnet services (such as the DNS service) can manipulate the service
in deep and possibly highly security sensitive ways. For example, the DNS
service can be used to intercept and alter any DNS query originating from
the local machine. Access to the APIs of these critical services and their
priviledged helpers must be tightly controlled.
@end table

@c FIXME: The titles of these chapters are too long in the index.

@menu
* Recommendation - Disable access to services via TCP::
* Recommendation - Run most services as system user "gnunet"::
* Recommendation - Control access to services using group "gnunet"::
* Recommendation - Limit access to certain SUID binaries by group "gnunet"::
* Recommendation - Limit access to critical gnunet-helper-dns to group "gnunetdns"::
* Differences between "make install" and these recommendations::
@end menu

@node Recommendation - Disable access to services via TCP
@subsubsection Recommendation - Disable access to services via TCP

GNUnet services allow two types of access: via TCP socket or via UNIX
domain socket.
If the service is available via TCP, access control can only be
implemented by restricting connections to a particular range of IP
addresses.
This is acceptable for non-critical services that are supposed to be
available to all users on the local system or local network.
However, as TCP is generally less efficient and it is rarely the case
that a single GNUnet peer is supposed to serve an entire local network,
the default configuration should disable TCP access to all GNUnet
services on systems with support for UNIX domain sockets.
As of GNUnet 0.9.2, configuration files with TCP access disabled should be
generated by default. Users can re-enable TCP access to particular
services simply by specifying a non-zero port number in the section of
the respective service.


@node Recommendation - Run most services as system user "gnunet"
@subsubsection Recommendation - Run most services as system user "gnunet"

GNUnet's main services should be run as a separate user "gnunet" in a
special group "gnunet".
The user "gnunet" should start the peer using "gnunet-arm -s" during
system startup. The home directory for this user should be
@file{/var/lib/gnunet} and the configuration file should be
@file{/etc/gnunet.conf}.
Only the @code{gnunet} user should have the right to access
@file{/var/lib/gnunet} (@emph{mode: 700}).

@node Recommendation - Control access to services using group "gnunet"
@subsubsection Recommendation - Control access to services using group "gnunet"

Users that should be allowed to use the GNUnet peer should be added to the
group "gnunet". Using GNUnet's access control mechanism for UNIX domain
sockets, those services that are considered useful to ordinary users
should be made available by setting "UNIX_MATCH_GID=YES" for those
services.
Again, as shipped, GNUnet provides reasonable defaults.
Permissions to access the transport and core subsystems might additionally
be granted without necessarily causing security concerns.
Some services, such as DNS, must NOT be made accessible to the "gnunet"
group (and should thus only be accessible to the "gnunet" user and
services running with this UID).

@node Recommendation - Limit access to certain SUID binaries by group "gnunet"
@subsubsection Recommendation - Limit access to certain SUID binaries by group "gnunet"

Most of GNUnet's SUID binaries should be safe even if executed by normal
users. However, it is possible to reduce the risk a little bit more by
making these binaries owned by the group "gnunet" and restricting their
execution to user of the group "gnunet" as well (4750).

@node Recommendation - Limit access to critical gnunet-helper-dns to group "gnunetdns"
@subsubsection Recommendation - Limit access to critical gnunet-helper-dns to group "gnunetdns"

A special group "gnunetdns" should be created for controlling access to
the "gnunet-helper-dns".
The binary should then be owned by root and be in group "gnunetdns" and
be installed SUID and only be group-executable (2750).
@b{Note that the group "gnunetdns" should have no users in it at all,
ever.}
The "gnunet-service-dns" program should be executed by user "gnunet" (via
gnunet-service-arm) with the binary owned by the user "root" and the group
"gnunetdns" and be SGID (2700). This way, @strong{only}
"gnunet-service-dns" can change its group to "gnunetdns" and execute the
helper, and the helper can then run as root (as per SUID).
Access to the API offered by "gnunet-service-dns" is in turn restricted
to the user "gnunet" (not the group!), which means that only
"benign" services can manipulate DNS queries using "gnunet-service-dns".

@node Differences between "make install" and these recommendations
@subsubsection Differences between "make install" and these recommendations

The current build system does not set all permissions automatically based
on the recommendations above. In particular, it does not use the group
"gnunet" at all (so setting gnunet-helpers other than the
gnunet-helper-dns to be owned by group "gnunet" must be done manually).
Furthermore, 'make install' will silently fail to set the DNS binaries to
be owned by group "gnunetdns" unless that group already exists (!).
An alternative name for the "gnunetdns" group can be specified using the
@code{--with-gnunetdns=GRPNAME} configure option.
