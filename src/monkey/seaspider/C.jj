/*

  C grammar defintion for use with JavaCC
  Contributed by Doug South (dsouth@squirrel.com.au) 21/3/97

  This parser assumes that the C source file has been preprocessed : all
  #includes have been included and all macros have been expanded. I accomplish
  this with "gcc -P -E <source file> > <output file>".

  There is a problem with compiler specific types, such as __signed, __const,
  __inline__, etc. These types can be added as typedef types before the parser
  is run on a file. See main() for an example. I have also found a strange little
  compiler specific "type" if you can call it that. It is __attribute__, but it
  does not seem to be used as a type. I found that just deleting the __attribute__
  and the following "offensive" code works.

  This grammar also prints out all the types defined while parsing the file. This
  is done via a call to printTypes() when the parser is complete. If you do not want
  this, just comment out the printTypes() method call in the production rule
  TranslationUnit(), which BTW is the root node for parsing a C source file.

  I have not in anyway extensively tested this grammar, in fact it is barely tested,
  but I imagine it is better to have a starting point for a C grammar other than from
  scratch. It has not been optimized in anyway, my main aim was to get a parser that
  works. Lookahead may not be optimum at choice points and may even be insufficient at
  times. I choose to err on the side of not optimum if I made a choice at all.

  If you use this grammar, I would appreciate hearing from you. I will try to maintain
  this grammar to the best of my ability, but at this point in time, this is only a side
  hobby (unless someone wants to pay me for doing JavaCC work!). In that regards, I am
  interested in hearing bugs and comments.

  TODO:

    Insert the appropriate code to enable C source trees from this grammar.

=============================================
3/2/06: Modified by Tom Copeland
- STRING_LITERAL now handles embedded escaped newlines, thanks to J.Chris Findlay for the patch
- Works with JavaCC 4.0
- Preprocessor directives are now simply SKIP'd, so no need to run C files through GCC first

31/8/10: Modified heavily by Christian Grothoff
- No more tracking of type names (so we can run without preprocessing)
- Support certain gcc-isms (unsigned long long, 33LL, etc.)
- No support for certain older C constructs
- Support for magic "GNUNET_PACKED" construct (extra "IDENTIFIER" in struct)

8/11/10: Modified some more by Christian Grothoff
- support for arguments without variable names (in particular, just 'void')
- support for string concatenations
*/

PARSER_BEGIN(CParser)

import java.util.*;

  public class CParser{

    // Run the parser
    public static void main ( String args [ ] ) {
      CParser parser ;

      if(args.length == 0){
        System.out.println("C Parser Version 0.1Alpha:  Reading from standard input . . .");
        parser = new CParser(System.in);
      }
      else if(args.length == 1){
        System.out.println("C Parser Version 0.1Alpha:  Reading from file " + args[0] + " . . ." );
      try {
        parser = new CParser(new java.io.FileInputStream(args[0]));
      }
      catch(java.io.FileNotFoundException e){
        System.out.println("C Parser Version 0.1:  File " + args[0] + " not found.");
        return ;
        }
      }
      else {
        System.out.println("C Parser Version 0.1Alpha:  Usage is one of:");
        System.out.println("         java CParser < inputfile");
        System.out.println("OR");
        System.out.println("         java CParser inputfile");
        return ;
      }
      try {
        parser.TranslationUnit();
        System.out.println("C Parser Version 0.1Alpha:  Java program parsed successfully.");
      }
      catch(ParseException e){
        System.out.println("C Parser Version 0.1Alpha:  Encountered errors during parse.");
        e.printStackTrace();
      }
    }
  }

PARSER_END(CParser)

SKIP : {
 " "
|  "\t"
|  "\n"
|  "\r"
|  <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
|  <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
| "#" : PREPROCESSOR_OUTPUT
}

<PREPROCESSOR_OUTPUT> SKIP:
{
     "\n" : DEFAULT
}

<PREPROCESSOR_OUTPUT> MORE:
{
 "\\\n"
 |
 "\\\r\n"
 |
 < ~[] >
}


TOKEN : {
 <INTEGER_LITERAL: <DECIMAL_LITERAL> (["l","L"])? (["l","L"])? | <HEX_LITERAL> (["l","L"])? (["l","L"])? | <OCTAL_LITERAL> (["l","L"])? (["l","L"])?>
|  <#DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|  <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+>
|  <#OCTAL_LITERAL: "0" (["0"-"7"])*>
|  <FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])? | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])? | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])? | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]>
|  <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+>
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
|   < STRING_LITERAL:
      ("\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\"")+
  >
}

TOKEN : {
	<CONTINUE: "continue"> |
	<VOLATILE: "volatile"> |
	<REGISTER: "register"> |
	<UNSIGNED: "unsigned"> |
	<TYPEDEF: "typedef"> |
	<DFLT: "default"> |
	<DOUBLE: "double"> |
	<SIZEOF: "sizeof"> |
	<SWITCH: "switch"> |
	<RETURN: "return"> |
	<EXTERN: "extern"> |
	<STRUCT: "struct"> |
	<STATIC: "static"> |
	<SIGNED: "signed"> |
	<WHILE: "while"> |
	<BREAK: "break"> |
	<UNION: "union"> |
	<CONST: "const"> |
	<FLOAT: "float"> |
	<SHORT: "short"> |
	<ELSE: "else"> |
	<CASE: "case"> |
	<LONG: "long"> |
	<ENUM: "enum"> |
	<AUTO: "auto"> |
	<VOID: "void"> |
	<CHAR: "char"> |
	<GOTO: "goto"> |
	<FOR: "for"> |
	<INT: "int"> |
	<IF: "if"> |
	<DO: "do">
}

TOKEN : {
 <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*>
|  <#LETTER: ["$","A"-"Z","_","a"-"z"]>
|  <#DIGIT: ["0"-"9"]>
}

void TranslationUnit() : {}
{
	(ExternalDeclaration())+
	<EOF>
}

void ExternalDeclaration() : {}
{
	(StorageClassSpecifier())*
	(
            LOOKAHEAD (FunctionDeclaration()) FunctionDeclaration() | 
	    LOOKAHEAD (StructOrUnionSpecifier() ";") StructOrUnionSpecifier() ";" |
	    LOOKAHEAD (EnumSpecifier() ";") EnumSpecifier() ";" |
	    LOOKAHEAD (VariableDeclaration()) VariableDeclaration() |
  	    LOOKAHEAD (TypeDeclaration()) TypeDeclaration () 
        ) 
}

void FunctionDeclaration() : {}
{
        TypeSpecifier () 
        <IDENTIFIER>
        "(" [ ParameterList () ] ")"
        ( ";" | CompoundStatement() )
}

void StorageClassSpecifier() : {}
{
	( <STATIC> | <EXTERN> )
}

void TypeDeclaration() : {}
{
        <TYPEDEF> 
        ( LOOKAHEAD (DataType() ";") DataType () | FunctionType() ) ";"
}

void DataType() : {}
{
        StructOrUnionSpecifier () <IDENTIFIER>
}

void FunctionType() : {}
{
        TypeSpecifier () "(" "*" <IDENTIFIER> ")" "(" [ ParameterList() ] ")"
}

void ParameterList() : {}
{
	ParameterDeclaration() ( LOOKAHEAD (2) "," ParameterDeclaration() )* [ "," "..." ]
}

void ParameterDeclaration() : {}
{
	TypeSpecifier() [<IDENTIFIER> [ Array () ]]
}

void VariableDeclaration() : {}
{
	VariableClassSpecifier () 
        TypeSpecifier () 
        InitDeclaratorList() ";"
}

void LocalVariableDeclaration() : {}
{
	[ <CONST> ] [ <STATIC> ] VariableDeclaration () 
}

void VariableClassSpecifier() : {}
{
	( <AUTO> | <REGISTER> )*
}

void TypeSpecifier() : {}
{
	[ <CONST> ]
	( <VOID> 
          | <CHAR> 
          | <SHORT> [ <INT> ]
          | <INT> 
          | <LONG> [ <LONG> ]  
          | <FLOAT> | <DOUBLE> 
          | (<SIGNED> | <UNSIGNED>) [ <CHAR> 
                                    | <SHORT> [ <INT> ]
                                    | <INT> 
                                    | <LONG> [ <LONG> ] ]
          | StructOrUnionSpecifier() 
          | EnumSpecifier() 
          | <IDENTIFIER> 
        )
        [ Pointer () ]
        [ Array () ]
}

/* this is needed for 'va_arg' where a type is an argument
   -- and we cannot disambiguate the use of 'FOO' 
   after a 'typedef int FOO' from the variable 'FOO'; 
   hence this hack */
void NoIdentifierTypeSpecifier() : {}
{
	[ <CONST> ]
	( <VOID> 
          | <CHAR> 
          | <SHORT> [ <INT> ]
          | <INT> 
          | <LONG> [ <LONG> ]  
          | <FLOAT> | <DOUBLE> 
          | (<SIGNED> | <UNSIGNED>) [ <CHAR> 
                                    | <SHORT> [ <INT> ]
                                    | <INT> 
                                    | <LONG> [ <LONG> ] ]
          | StructOrUnionSpecifier() 
          | EnumSpecifier() 
        )
        [ Pointer () ]
        [ Array () ]
}

void StructOrUnionSpecifier() : {}
{
        LOOKAHEAD (3)
	StructOrUnion() [ <IDENTIFIER> ] "{" StructDeclarationList() "}"  |
	StructOrUnion() <IDENTIFIER>  
}

void StructOrUnion() : {}
{
	( <STRUCT> | <UNION> )
}

void StructDeclarationList() : {}
{
	(StructDeclaration())*
}

void InitDeclaratorList() : {}
{
	InitDeclarator() ("," InitDeclarator())*
}

void InitDeclarator() : {}
{
	<IDENTIFIER> [ Array () ] [ "=" Initializer() ]
}

void StructDeclaration() : {}
{
	TypeSpecifier() <IDENTIFIER> [ Array() | ":" ConstantExpression() ] [ <IDENTIFIER> ] ";"
}

void EnumSpecifier() : {}
{
	<ENUM> ( LOOKAHEAD(3) [ <IDENTIFIER> ] "{" EnumeratorList() "}" | <IDENTIFIER> )
}

void EnumeratorList() : {}
{
	Enumerator() ("," Enumerator())*
}

void Enumerator() : {}
{
	<IDENTIFIER> [ "=" ConstantExpression() ]
}

void Pointer() : {}
{
	"*" [ <CONST> ] [ Pointer() ]
}

void Initializer() : {}
{
	( AssignmentExpression() |
	  "{" InitializerList() [","] "}" )
}

void InitializerList() : {}
{
	Initializer() (LOOKAHEAD(2) "," Initializer())*
}


void Array() : {}
{
   ("[" [ConstantExpression()] "]" )+
}

void Statement() : {}
{
	( LOOKAHEAD(2) LabeledStatement() |
	  ExpressionStatement() |
	  CompoundStatement() |
	  SelectionStatement() |
	  IterationStatement() |
	  JumpStatement() )
}

void LabeledStatement() : {}
{
	( <IDENTIFIER> ":" Statement() |
	  <CASE> ConstantExpression() ":" Statement() |
	  <DFLT> ":" Statement() )
}

void ExpressionStatement() : {}
{
	[ Expression() ] ";"
}

void CompoundStatement() : {}
{
	"{"   ( LOOKAHEAD (LocalVariableDeclaration()) LocalVariableDeclaration () |
	        Statement() )*
	"}"
}

void SelectionStatement() : {}
{
	( IfStatement() | SwitchStatement() )
}

void IfStatement() : {}
{
	 <IF> "(" Expression() ")" Statement() [ LOOKAHEAD(2) <ELSE> Statement() ] 
}

void SwitchStatement() : {}
{
	  <SWITCH> "(" Expression() ")" Statement() 
}

void IterationStatement() : {}
{
	( WhileStatement() | DoWhileStatement() | ForStatement() )
}
void WhileStatement() : {}
{
	<WHILE> "(" Expression() ")" Statement() 
}
void DoWhileStatement() : {}
{
	  <DO> Statement() <WHILE> "(" Expression() ")" ";" 
}
void ForStatement() : {}
{
	  <FOR> "(" [ Expression() ] ";" [ Expression() ] ";" [ Expression() ] ")" Statement() 
}

void JumpStatement() : {}
{
	( <GOTO> <IDENTIFIER> ";" |
	  <CONTINUE> ";" |
	  <BREAK> ";" |
	  <RETURN> [ Expression() ] ";" )
}

void Expression() : {}
{
	 AssignmentExpression() ( "," AssignmentExpression() )*
}

void AssignmentExpression() : {}
{
	  LOOKAHEAD(UnaryExpression() AssignmentOperator()) UnaryExpression() AssignmentOperator() AssignmentExpression() |
	  LOOKAHEAD(3) ConditionalExpression()
}

void AssignmentOperator() : {}
{
	( "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | "&=" | "^=" | "|=" )
}

void ConditionalExpression() : {}
{
	LogicalORExpression() [ "?" Expression() ":" ConditionalExpression() ]
}

void ConstantExpression() : {}
{
	ConditionalExpression()
}

void LogicalORExpression() : {}
{
	LogicalANDExpression() [ "||" LogicalORExpression() ]
}

void LogicalANDExpression() : {}
{
	InclusiveORExpression() [ "&&" LogicalANDExpression() ]
}

void InclusiveORExpression() : {}
{
	ExclusiveORExpression() [ "|" InclusiveORExpression() ]
}

void ExclusiveORExpression() : {}
{
	ANDExpression() [ "^" ExclusiveORExpression() ]
}

void ANDExpression() : {}
{
	EqualityExpression() [ "&" ANDExpression() ]
}

void EqualityExpression() : {}
{
	RelationalExpression() [ ( "==" | "!=" ) EqualityExpression() ]
}

void RelationalExpression() : {}
{
	ShiftExpression() [ ( "<" | ">" | "<=" | ">=" ) RelationalExpression() ]
}

void ShiftExpression() : {}
{
	AdditiveExpression() [ ( "<<" | ">>" ) ShiftExpression() ]
}

void AdditiveExpression() : {}
{
	MultiplicativeExpression() [ ( "+" | "-" ) AdditiveExpression() ]
}

void MultiplicativeExpression() : {}
{
	CastExpression() [ ( "*" | "/" | "%" ) MultiplicativeExpression() ]
}

void CastExpression() : {}
{
	( LOOKAHEAD("(" TypeSpecifier() ")" CastExpression() ) "(" TypeSpecifier() ")" CastExpression() |
	  UnaryExpression() )
}

void UnaryExpression() : {}
{
	( LOOKAHEAD(3) PostfixExpression() |
	  "++" UnaryExpression() |
	  "--" UnaryExpression() |
	  UnaryOperator() CastExpression() |
	  <SIZEOF> ( LOOKAHEAD(UnaryExpression() ) UnaryExpression() | "(" TypeSpecifier() ")" ) )
}

void UnaryOperator() : {}
{
	( "&" | "*" | "+" | "-" | "~" | "!" )
}

void PostfixExpression() : {}
{
	PrimaryExpression() ( "[" Expression() "]" |
	                      "(" [ LOOKAHEAD(ArgumentExpressionList() ) ArgumentExpressionList() ] ")" |
	  					  "." <IDENTIFIER> |
	  					  "->" <IDENTIFIER> |
	  					  "++" |
	  					  "--" )*
}

void PrimaryExpression() : {}
{
	 <IDENTIFIER> |
	  Constant() |
	  "(" Expression() ")" 
}

void ArgumentExpressionList() : {}
{
	AssignmentOrTypeExpression() ( "," AssignmentOrTypeExpression() )*
}


void AssignmentOrTypeExpression() : {}
{
	NoIdentifierTypeSpecifier() |
	AssignmentExpression() 
}

void Constant() : {}
{
  <INTEGER_LITERAL> |
  <FLOATING_POINT_LITERAL> | 
  <CHARACTER_LITERAL> | 
  (<STRING_LITERAL>)+
}

