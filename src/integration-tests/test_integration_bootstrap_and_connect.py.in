#!@PYTHON@
#    This file is part of GNUnet.
#    (C) 2010 Christian Grothoff (and other contributing authors)
#
#    GNUnet is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published
#    by the Free Software Foundation; either version 2, or (at your
#    option) any later version.
#
#    GNUnet is distributed in the hope that it will be useful, but
#    WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with GNUnet; see the file COPYING.  If not, write to the
#    Free Software Foundation, Inc., 59 Temple Place - Suite 330,
#    Boston, MA 02111-1307, USA.
#
# 
import sys
import os
import subprocess
import re
import shutil
import time
import pexpect

#
# This test tests if a fresh peer bootstraps from a hostlist server and then
# successfully connects to the server 
#
# Conditions for successful exit:
# Both peers have 1 connected peer in transport, core, topology, fs

#definitions

testname = "test_integration_bootstrap_and_connect"
verbose = False
gnunetarm = ""
gnunetstatistics = ""
success = False
timeout = 100

#test conditions

#server
server_transport_connected = False
server_topology_connected = False
server_core_connected = False
server_fs_connected = False

client_transport_connected = False
client_topology_connected = False
client_core_connected = False
client_fs_connected = False

def vprintf (msg):
    if verbose == True:
        print msg

def setup ():
  srcdir = "../.."
  gnunet_pyexpect_dir = os.path.join (srcdir, "contrib")
  if gnunet_pyexpect_dir not in sys.path:
    sys.path.append (gnunet_pyexpect_dir)
  from gnunet_pyexpect import pexpect
  global gnunetarm    	
  global gnunetstatistics
  if os.name == 'posix':
    gnunetarm = 'gnunet-arm'
    gnunetstatistics = 'gnunet-statistics'
  elif os.name == 'nt':
    gnunetarm = 'gnunet-arm.exe'
    gnunetstatistics = 'gnunet-statistics.exe'    
  if os.name == "nt":
    shutil.rmtree (os.path.join (os.getenv ("TEMP"), testname), True)
  else:
    shutil.rmtree ("/tmp/" + testname, True)

def start ():
	vprintf ("Starting bootstrap server & client")
	try:
	    server = subprocess.Popen ([gnunetarm, '-sq', '-c', './confs/c_bootstrap_server.conf'])
	    server.communicate ()    
	except OSError:
	    print "Can not start bootstrap server, exiting..."
	    exit (1)
	try:
	    client = subprocess.Popen ([gnunetarm, '-sq', '-c', 'confs/c_no_nat_client.conf'])
	    client.communicate ()    
	except OSError:
	    print "Can not start bootstrap client, exiting..."
	    exit (1)
	vprintf ("Bootstrap server & client started")

def stop ():
	vprintf ("Shutting down bootstrap server")
	try:
	    server = subprocess.Popen ([gnunetarm, '-eq', '-c', './confs/c_bootstrap_server.conf'])
	    server.communicate ()    
	except OSError:
	    print "Can not stop bootstrap server, exiting..."
	    exit (1)
	try:
	    client = subprocess.Popen ([gnunetarm, '-eq', '-c', 'confs/c_no_nat_client.conf'])
	    client.communicate ()    
	except OSError:
	    print "Can not stop bootstrap client, exiting..."
	    exit (1)
	vprintf ("Bootstrap server & client stopped")


def cleanup ():
	if os.name == "nt":
	    shutil.rmtree (os.path.join (os.getenv ("TEMP"), "gnunet-test-fs-py-ns"), True)
	    shutil.rmtree (os.path.join (os.getenv ("TEMP"), "c_no_nat_client"), True)
	else:
	    shutil.rmtree ("/tmp/c_bootstrap_server/", True)
	    shutil.rmtree ("/tmp/c_no_nat_client/", True)

def check_statistics (conf, subsystem, name, value):
    from gnunet_pyexpect import pexpect
    server = pexpect ()
    server.spawn (None, [gnunetstatistics, '-c', conf ,'-q','-n', name, '-s', subsystem ], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    #server.expect ("stdout", re.compile (r""))
    test = server.read("stdout", 10240)
    if (test.find(str(value)) == -1): 
        return False
    else:
        return True 
    
    

def check ():
  global success
  global timeout
  global publish
  global server_transport_connected
  global server_topology_connected
  global server_core_connected
  global server_fs_connected
  
  global client_transport_connected
  global client_topology_connected
  global client_core_connected
  global client_fs_connected

  count = 1
  while ((success == False) and (count <= timeout)):
  	# Perform checks   	
	if ((False == server_transport_connected) and (True == check_statistics ('./confs/c_bootstrap_server.conf', 'transport', '# peers connected',1))):
	  server_transport_connected = True
	  vprintf ('Server transport services is connected')
	  
	if ((False == client_transport_connected) and (True == check_statistics ('./confs/c_no_nat_client.conf', 'transport', '# peers connected',1))):
	  client_transport_connected = True
	  vprintf ('Client transport services is connected')

	if ((False == server_core_connected) and (True == check_statistics ('./confs/c_bootstrap_server.conf', 'core', '# neighbour entries allocated',1))):
	  server_core_connected = True
	  vprintf ('Server core services is connected')
	  
	if ((False == client_core_connected) and (True == check_statistics ('./confs/c_no_nat_client.conf', 'core', '# neighbour entries allocated',1))):
	  client_core_connected = True
	  vprintf ('Client core services is connected')

	if ((False == server_topology_connected) and (True == check_statistics ('./confs/c_bootstrap_server.conf', 'topology', '# peers connected',1))):
	  server_topology_connected = True
	  vprintf ('Server topology services is connected')
	  
	if ((False == client_topology_connected) and (True == check_statistics ('./confs/c_no_nat_client.conf', 'topology', '# peers connected',1))):
	  client_topology_connected = True
	  vprintf ('Client topology services is connected')
	  
	if ((False == client_fs_connected) and (True == check_statistics ('./confs/c_no_nat_client.conf', 'fs', '# peers connected',1))):
	  client_fs_connected = True
	  vprintf ('Client fs services is connected')
	if ((False == server_fs_connected) and (True == check_statistics ('./confs/c_bootstrap_server.conf', 'fs', '# peers connected',1))):
	  server_fs_connected = True
	  vprintf ('Server fs services is connected')	  
	    
	# Check if conditions fulfilled
	if ((True == client_transport_connected) and (True == server_transport_connected) and 
	(True == client_topology_connected) and (True == server_topology_connected) and 
	(True == client_core_connected) and (True == server_core_connected) and
	(True == client_fs_connected) and (True == server_fs_connected)):
		success = True
		break 
	print '.'
	time.sleep(1)
	count += 1
  if (success == False):
		if (client_transport_connected == False):
			print ('Client transport was NOT connected')
		if (server_transport_connected == False):
			print ('Server transport was NOT connected')
		if (client_topology_connected == False):
			print ('Client topology was NOT connected')
		if (server_topology_connected == False):
			print ('Server topology was NOT connected')
		if (client_core_connected == False):
			print ('Client core was NOT connected')
		if (server_core_connected == False):
			print ('Server core was NOT connected')

# 
# Test execution
# 

vprintf ("Running " + testname)
setup ()
start ()

check ()

stop ()
cleanup ()

if (success == False):
	print ('Test failed')
	exit (1)
else:
	print ('Test successful')
	exit (0)



