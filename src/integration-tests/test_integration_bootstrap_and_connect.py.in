#!@PYTHON@
#    This file is part of GNUnet.
#    (C) 2010 Christian Grothoff (and other contributing authors)
#
#    GNUnet is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published
#    by the Free Software Foundation; either version 2, or (at your
#    option) any later version.
#
#    GNUnet is distributed in the hope that it will be useful, but
#    WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with GNUnet; see the file COPYING.  If not, write to the
#    Free Software Foundation, Inc., 59 Temple Place - Suite 330,
#    Boston, MA 02111-1307, USA.
#
# 
import sys
import os
import subprocess
import re
import shutil
import time
import pexpect




#
# This test tests if a fresh peer bootstraps from a hostlist server and then
# successfully connects to the server 
#

#definitions

testname = "test_integration_bootstrap_and_connect"
verbose = True
gnunetarm = ""
gnunetstatistics = ""
#fix this!
success = False
timeout = 10

#test conditions

#server
server_transport_connected = False
server_topology_connected = False
server_core_connected = False

client_transport_connected = False
client_topology_connected = False
client_core_connected = False


def vprintf (msg):
    if verbose == True:
        print msg

def setup ():
  srcdir = "../.."
  gnunet_pyexpect_dir = os.path.join (srcdir, "contrib")
  if gnunet_pyexpect_dir not in sys.path:
    sys.path.append (gnunet_pyexpect_dir)
  from gnunet_pyexpect import pexpect
  global gnunetarm    	
  global gnunetstatistics
  if os.name == 'posix':
    gnunetarm = 'gnunet-arm'
    gnunetstatistics = 'gnunet-statistics'
  elif os.name == 'nt':
    gnunetarm = 'gnunet-arm.exe'
    gnunetstatistics = 'gnunet-statistics.exe'    
  if os.name == "nt":
    shutil.rmtree (os.path.join (os.getenv ("TEMP"), testname), True)
  else:
    shutil.rmtree ("/tmp/" + testname, True)

def start ():
	vprintf ("Starting bootstrap server & client")
	try:
	    server = subprocess.Popen ([gnunetarm, '-sq', '-c', './confs/c_bootstrap_server.conf'])
	    server.communicate ()    
	except OSError:
	    print "Can not start bootstrap server, exiting..."
	    exit (1)
	try:
	    client = subprocess.Popen ([gnunetarm, '-sq', '-c', 'confs/c_no_nat_client.conf'])
	    client.communicate ()    
	except OSError:
	    print "Can not start bootstrap client, exiting..."
	    exit (1)
	vprintf ("Bootstrap server & client started")

def stop ():
	vprintf ("Shutting down bootstrap server")
	try:
	    server = subprocess.Popen ([gnunetarm, '-eq', '-c', './confs/c_bootstrap_server.conf'])
	    server.communicate ()    
	except OSError:
	    print "Can not stop bootstrap server, exiting..."
	    exit (1)
	try:
	    client = subprocess.Popen ([gnunetarm, '-eq', '-c', 'confs/c_no_nat_client.conf'])
	    client.communicate ()    
	except OSError:
	    print "Can not stop bootstrap client, exiting..."
	    exit (1)
	vprintf ("Bootstrap server & client stopped")


def cleanup ():
	if os.name == "nt":
	    shutil.rmtree (os.path.join (os.getenv ("TEMP"), "gnunet-test-fs-py-ns"), True)
	else:
	    shutil.rmtree ("/tmp/gnunet-test-fs-py-ns", True)

def check_statistics (conf, subsystem, name, value):
    from gnunet_pyexpect import pexpect
    server = pexpect ()
    server.spawn (None, [gnunetstatistics, '-c', conf ,'-q','-n', name, '-s', subsystem ], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    #server.expect ("stdout", re.compile (r""))
    test = server.read("stdout", 10240)
    if (test.find(str(value)) == -1): 
        return False
    else:
        return True 
    
    

def check ():
  global success
  global timeout
  global publish

  count = 1
  print 'check'
  while ((success == False) and (count <= timeout)):
    if (True == check_statistics ('./confs/c_bootstrap_server.conf', 'transport', '# peers connected',1)):
        vprintf ('Server transport services is connected')
    if (True == check_statistics ('./confs/c_no_nat_client.conf', 'transport', '# peers connected',1)):
        vprintf ('Client transport services is connected')           
    time.sleep(1)
    count += 1 

# 
# Test execution
# 

vprintf ("Running " + testname)
setup ()
start ()

check ()

#stop ()
cleanup ()

if (success == False):
	print ('Test failed')
	exit (1)
else:
	print ('Test successful')
	exit (0)



